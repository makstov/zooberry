\documentclass[a4paper,landscape]{slides}
%\usepackage{proof,latexsym,hangul}
\usepackage{proof,xspace,amsmath,latexsym}
\input{macroA}\input{macroB}
%\input{psfig}
\usepackage{color} %\textcolor{red}{}
  \definecolor{grey}{rgb}{0.0,0.0,0.0}
  \definecolor{wgray}{rgb}{0.5,0.5,0.5}
  \definecolor{gray}{rgb}{0.5,0.5,0.5}
  \definecolor{blue}{rgb}{0.6,0.3,1}
  \definecolor{tblue}{rgb}{0,0,1}
  \definecolor{red}{rgb}{1,0.2,0.2}
\newcommand{\gmbox}[1]{\mbox{\textcolor{wgray}{#1}}}
\newcommand{\gray}[1]{\textcolor{wgray}{#1}}

\newcommand{\bb}[1]{\lbrack\!\lbrack #1 \rbrack\!\rbrack} 
\newcommand{\Meta}[1]{{\it #1\/}}
\newenvironment{tp}[1]{%
        \begin{slide}\heading{#1}}{\vspace*{\fill}\end{slide}}
\newcommand{\heading}[1]{%
        \begin{flushleft}%
                \large{$\Box$ \sf\bf #1}\\*[-.9em]
                \rule{\textwidth}{.1cm}%
        \end{flushleft}}

\input{macroTalk}

\title{\bf 
\textcolor{blue}{The Rabbit Specification Language for Program
                Analysis}
}
\author{\large \\ 
  \begin{center}
  Kwangkeun Yi\\
  Research On Program Analysis System\\
  {\tt ropas.kaist.ac.kr}\\
  KAIST\\
  \ \\
 2/24/2001
  \end{center}
}
\date{\empty}
\bd
\begin{slide}
  \thispagestyle{empty}
  \maketitle
  \addtocounter{slide}{-1}
\end{slide}
%%%%%%%%%%%%%
%\psfig{figure=rabbit-logo.eps}
%%%%%%%%%%%%%
\begin{tp}{Rabbit Is}
a domain-specific, high-level language to express
\bi
\item \textcolor{gray}{program analysis} and
\item \textcolor{gray}{static properties}
\ei
\end{tp}
%%%%%%%%%%%%%
\begin{tp}{Motivation}
\bi
\item need a convenient tool to generate realistic yet
ambitious program analyzers.
 \bi
 \item \textcolor{gray}{aim it for being used in our LET
 project, in developing our nML compiler for FCC
 (fixpoint-carryincd-code)}
 \ei
\item best way to transfer our program analysis technology to
the industry is to provide a convenient high-level tool
\ei
\end{tp}
%%%%%%%%%%%%%
\begin{tp}{Program Analysis}
 \bi
 \item how to set-up equations from a program: 
 \textcolor{gray}{abstract interpreters}
 \item how to solve the equations: \textcolor{gray}{fixpoint engine}
 \item how to query the solutions: \textcolor{gray}{CTL formula}
 \ei
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Program Analysis: An Example}
to analyze programs $e$:
\[
\begin{array}{rcll}
e &::=& z & \gmbox{integer}\\
  &|& x &\gmbox{variable}\\
  &|& x\;\tl{:=}\;e &\gmbox{assignment}\\
  &|& e\;\tl{+}\;e &\gmbox{addition}\\
  &|& e\;\tl{;}\;e &\gmbox{sequence}\\
  &|& \tl{if}\;e\;e\;e &\gmbox{choice}
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{An Abstract Interpreter}
\[
\begin{array}{rcl}
s &\in&\nt{Var}\to\nt{Sign}\\
&&\\
E(z,s) &=& (\nt{sign}(z),s)\\
&&\\
E(x,s) &=& (s(x),s)\\
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Cont'd}
\[
\begin{array}{rcl}
E(x\tl{:=} e, s) &=& \nt{let}\; (v_1,s_1) = E(e,s)\\
                 && \nt{in}\; (v_1, s_1[v_1/x])\\
&&\\
E(e_1\tl{;}e_2) &=&\nt{let}\; (v_1,s_1) = E(e_1,s)\\
                &&\quad     (v_2,s_2) = E(e_2,s_1)\\
                &&\nt{in}\; (v_2,s_2)\\
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%%
\begin{tp}{Cont'd}
\[
\begin{array}{rcl}
E(e_1\tl{+}e_2, s) &=&\nt{let}\; (v_1,s_1) = E(e_1,s)\\
                  &&\quad    (v_2,s_2) = E(e_2,s_1)\\
                  &&\nt{in}\; (\nt{add}(v_1,v_2),s_2)\\
&&\\
E(\tl{if}\;e_1\;e_2\;e_3, s) &=&\nt{let}\; (v_1,s_1) = E(e_1,s)\\
&&\quad	 (v_2,s_2) = E(e_2,s_1)\\
&&\quad  (v_3,s_3) = E(e_3,s_1)\\
&&\nt{in}\; (v_2,s_2)\cup(v_3,s_3)
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\[
\begin{array}{rcl}
s &\in&\nt{Var}\to\nt{Sign}\\
\E(z,s) &=& (\nt{sign}(z),s)\\
\E(x,s) &=& (s(x),s)\\
\E(x\tl{:=} e, s) &=& \nt{let}\; (v_1,s_1) = \E(e,s)\\
                 && \nt{in}\; (v_1, s_1[v_1/x])\\
\E(e_1\tl{;}e_2) &=&\nt{let}\; (v_1,s_1) = \E(e_1,s)\\
                &&\quad     (v_2,s_2) = \E(e_2,s_1)\\
                &&\nt{in}\; (v_2,s_2)\\
\E(e_1\tl{+}e_2, s) &=&\nt{let}\; (v_1,s_1) = \E(e_1,s)\\
                  &&\quad    (v_2,s_2) = \E(e_2,s_1)\\
                  &&\nt{in}\; (\nt{add}(v_1,v_2),s_2)\\
\E(\tl{if}\;e_1\;e_2\;e_3, s) &=&\nt{let}\; (v_1,s_1) = \E(e_1,s)\\
&&\quad	 (v_2,s_2) = \E(e_2,s_1)\\
&&\quad  (v_3,s_3) = \E(e_3,s_1)\\
&&\nt{in}\; (v_2,s_2)\cup(v_3,s_3)
\end{array}
\]
%%%%%%%%%%%%%%
\begin{tp}{Derving Equations from an Input Program}
The abstract interpreter is the skeleton. Consider an input program:
\ \\
\ \\
\begin{Cmode}
            x := 1;
            if x then y := y+1 else x := x+1
\end{Cmode}

\end{tp}
%%%%%%%%%%%%%%
\newcommand{\ein}{E^{\nt{pre}}}
\newcommand{\eout}{E^{\nt{post}}}

\begin{tp}{Equations}
\[
\begin{array}{rclcrcl}
\textcolor{gray}{\ein_i} &
\textcolor{gray}{\in}&
\textcolor{gray}{\nt{Var}\to\nt{Sign}}&\qquad&
\textcolor{gray}{\eout_i} &
\textcolor{gray}{\in} &
\textcolor{gray}{\nt{Sign}\times(\nt{Var}\to\nt{Sign})}\\
&&&&&&\\
\ein_1 &=& \bot && \eout_1 &=& \eout_5\\
&&&&&&\\
\ein_2 &=& \ein_1 && \eout_5 &=& \eout_{10}\cup\eout_{11}\\
&&&&&&\\
\ein_4 &=& \eout_1.2[1/x] && \cdots &&\\
\cdots&&&&&&\\
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Higher-order Language Case}
\[
\begin{array}{rcll}
e &::=& x &\gmbox{variable}\\
  &|& \lambda x. e &\gmbox{abstraction}\\
  &|& e\;\;e &\gmbox{application}
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{An Abstract Interpreter}
(with dynamic binding)
\[
\begin{array}{rcl}
s &\in&\nt{Var}\to\nt{Expr}\\
&&\\
\E(x,s) &=& (s(x),s)\\
\E(\lambda x.e, s) &=& (\lambda x.e, s)\\
\E(e_1\; e_2,s) &=&\nt{let}\; \lambda x.e' = \E(e_1,s)\\
                &&\quad     v = \E(e_2,s)\\
		&&\quad     v' = \E(e', s[v/x])\\
                &&\nt{in}\; (v',s)\\
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Derving Equations from an Input Program}
\begin{Cmode}
              ($\lambda$ x. (x x))($\lambda$ y.y)
\end{Cmode}
\[
\begin{array}{rclcrcl}
\textcolor{gray}{\ein_i} &
\textcolor{gray}{\in}&
\textcolor{gray}{\nt{Var}\to\nt{Expr}}&\qquad&
\textcolor{gray}{\eout_i} &
\textcolor{gray}{\in} &
\textcolor{gray}{\nt{Sign}\times(\nt{Var}\to\nt{Out})}\\
&&&&&&\\
\ein_1 &=& \bot && \eout_1 &=& \eout_{7}\\
&&&&&&\\
\ein_2 &=& \eout_{3} && \eout_2 &=& \lambda\tl{x.(x x)}\\
&&&&&&\\
\ein_3 &=& \eout_2 && \eout_3 &=& \lambda\tl{y.y}\\
&&&&&&\\
\eout_4 &=& \eout_{\eout_5} && \cdots&&\\
\cdots&&&&&&
\end{array}
\]
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Solving the Equation}
The fixpoint iteration
\bi
\item many techniques are possible
 \bi
 \item \textcolor{gray}{worklist version}
 \item \textcolor{gray}{parallel version}
 \item \textcolor{gray}{exploiting, if any, distributivity of the operators in the equations}
 \ei
\item all three seem to be orthogonal techniques
\ei
\end{tp}
%%%%%%%%%%%%%%
\begin{tp}{Query (Property) about the Solutions}
\bi
\item always from this expression, does variable x remain positive forever?
 \bi
 \item \textcolor{gray}{$s:pre.AG(s':pre.s(x)=s'(x)=\oplus)$}
 \ei
\item next to this expression, does variable x remain positive?
 \bi
 \item \textcolor{gray}{$s:pre.AX(s':pre.s(x)=s'(x)=\oplus)$}
 \ei
\ei
\end{tp}
\begin{tp}{Cont'd}
\bi
\item sometimes from this expression, can variable x remain positive?
 \bi
 \item \textcolor{gray}{$s:pre.EF(s':pre.s(x)=s'(x)=\oplus)$}
 \ei
\item always from this expression, does variable x remain positive
      until y is negative?
 \bi
 \item \textcolor{gray}{$s:pre.EU(s':pre.s(x)=s'(x)=\oplus, s'(y)=\ominus)$}
 \ei
\ei
\end{tp}
%%%%%%%%%%%%%%
\[
\begin{array}{rcll}
\spec &::=& \domain\;\semantics\;\may{\query} &\\
&&&\\
\domain &::=& \setdec\;|\;\latdec\;|\;\widendec &\\
	&|& \domain_1\;\domain_2 &\\
\setdec &::=& \tl{set}\;\setbind &\\
%        &|& \setdec_1\;\setdec_2 &\\
\setbind &::=& \setid\;\tl{=}\;\setexp &\\
\setexp
 &::=&\tl{/}\nt{tylongid}\tl{/} & \gmbox{nML type id}\\
 &|&\setid                  & \gmbox{set id}\\
 &|&\braceExp{\eO\;\tl{...}\;\eT}	& \gmbox{integer interval set}\\
 &|&\braceExp{\elmtidrow} 		& \gmbox{enumerated set}\\
 &|&\tl{power}\;\setexp 		& \gmbox{power set}\\
 &|&\setexp_1\;\tl{*}\;\setexp_2	& \gmbox{cartesian product}\\
 &|&\setexp_1\;\tl{+}\;\setexp_2	& \gmbox{separated sum}\\
 &|&\setexp_1\;\tl{->}\;\setexp_2	& \gmbox{finite function set}\\
\end{array}
\]
\[
\begin{array}{rcll}
\latdec &::=&\tl{lattice}\;\latbind &\\
%        &|& \latdec_1\;\latdec_2 &\\
\latbind&::= &\latid\;\tl{=}\;\latexp &\\
\latexp &::=&\tl{/}\nt{strlongid}\tl{/} & \gmbox{nML structure id}\\
  &|&\latid			 & \gmbox{lattice id}\\
  &|&\tl{flat}\;\setexp          & \gmbox{flat lattice}\\
  &|&\tl{power}\;\setexp         & \gmbox{powerset lattice}\\
  &|&\latexp_1\;\tl{*}\;\latexp_2  & \gmbox{cartesian product}\\
  &|&\latexp_1\;\tl{+}\;\latexp_2  & \gmbox{coalesced sum}\\       
  &|&\latexp_1\;\tl{->}\;\latexp_2 & \gmbox{atomic function lattice}\\
  &|&\setexp\;\tl{->}\;\latexp & \gmbox{dependent product lattice}\\
  &|&\setexp\;\tl{order}\;\nt{order} &\gmbox{lattice with explicit orders}\\
\nt{order}&::=& \nt{po}\;\nt{pat} &\gmbox{chain}\\
          &|& \nt{order}_1\;\tl{|}\;\nt{order}_2\\
          &\sugar& \nt{pat}\;(\nt{po}\;\nt{pat})^+ &\\
\nt{po} &::=&\tl{<}\;\; |\;\;\tl{>} &\gmbox{partial order}\\
&&&\\
\widendec &::=&\tl{widen}\;\latid\;\tl{with}\;\match &
\end{array}
\]

\[
\begin{array}{rcll}
\e&::=& \tl{/}\m{\nt{ne}}\tl{/}	&\gmbox{embedded nML expr}\\
 & |& \setid      		&\gmbox{set itself}\\
 & |& \constant			&\gmbox{constant}\\
 & |& \varid			&\gmbox{bound id}\\
 & |& \eO\;\bop\;\eT 		&\gmbox{binary op}\\
 & |& \braceExp{\eO\;\tl{...}\;\eT} & \gmbox{integer set}\\
 & |& \braceExp{\erow}		& \gmbox{set}\\
 & |& \setcomExp{\e}{\qual}	& \gmbox{set comprehension}\\
 & |& \braceExp{\mrulerow}      & \gmbox{map}\\
 & |& \setcomExp{\mrule}{\qual} & \gmbox{map comprehension}\\
 & |& \foldExp{\tl{+}}{\e}      &\gmbox{fold join}\\
 & |& \foldExp{\tl{*}}{\e}      &\gmbox{fold meet}\\
 & |& \tupleExp{\e_1}{\e_2}	&\gmbox{tuple}\\ 
 & |& \projExp{\e}{\tl{1}}\;\;|\;\;\projExp{\e}{\tl{2}}	&\gmbox{projection}\\ 
 & |& \injExp{\e}{\ty}{\tl{1}}\;\;|\;\;\injExp{\e}{\ty}{\tl{2}} 
							&\gmbox{injection}\\
 & |& \letExp{\valdec}{\e}	&\gmbox{local expr}\\
 & |& \fnExp{\match}		&\gmbox{abstraction}\\
 & |& \appExp{\eO}{\eT} 	&\gmbox{application or map image}\\
\end{array}
\]
\[
\begin{array}{rcll}
 & |& \parenExp{\e}		&\\
 & |& \coerceExp{\e}{\ty}	&\gmbox{coercion}\\
 &\sugar&\tupleExp{\e}{\erow}	&\gmbox{tuple}\\
 &\sugar&\projExp{\e}{\domid}	&\gmbox{projection}\\
 &\sugar&\modiExp{\e}{\mrule}	&\gmbox{modifying map}\\
% &\sugar&\modiExp{\eO}{\domid\;\tl{=>}\;\eT} &\gmbox{modifying tuple}\\
 &\sugar&\mapExp{\match} 	&\gmbox{map}\\
 &\sugar&\caseExp{\e}{\match} 	&\gmbox{branch}\\
% &\sugar&\ifExp{\eO}{\eT}{\eR} &\gmbox{branch}\\
\bop &::= & \tl{+}\;|\;\tl{*}\;|\;\tl{-} &\gmbox{join, meet, set-minus}\\
\constant &::=& \nt{integer}   	&\\
 &|&\elmtid		&\gmbox{set element id}\\
 &|&\tl{top}		&\gmbox{lattice top}\\
 &|&\tl{bottom}		&\gmbox{lattice bottom}\\
\m{\nt{ne}}
 &::=& \rabbitId{\varid}	&\gmbox{rabbit id}\\
 &|&   \nt{nmlexp} &\gmbox{nML expr with embedded rabbit id}\\
\ty &::=&\tl{int}\;|\;\tl{bool}\;|\;\domid\;|\;\tl{/}\nt{tylongid}\tl{/} &\\
    & | &\ty_1\;\tl{*}\;\ty_2\;|\;\ty_1\;\tl{+}\;\ty_2 &\\
    & | &\ty_1\;\tl{->}\;\ty_2\;|\;\tl{power}\;\ty &\\
%    & | &\parenExp{\ty\;\tl{,}\;\tl{1}}\;|\;\parenExp{\ty\;\tl{,}\;\tl{2}}&
\end{array}
\]
\[
\begin{array}{rcll}
\qual &::=& \gen\;\may{\tl{,}\;\guard} &\\
\gen &::=&\genPat{\pat}{\e}        &\gmbox{for each element of a set}\\
     &|&\genPat{\mpat}{\e}  &\gmbox{for each entry of a map}\\
     &|&\gen_1\;\tl{,}\;\gen_2 &\\
\guard &::=&\eO\;\rop\;\eT	   	 &\gmbox{relation}\\
       & |& \eO\;\tl{in}\;\eT		 &\gmbox{membership}\\
       & |& \tl{not}\;\guard		 &\\
       & |& \guard_1\;\tl{and}\;\guard_2 &\\
       & |& \guard_1\;\tl{or}\;\guard_2  &\\
       & |& \forallGuard{\gen}{\guard}		&\gmbox{for all}\\
       & |& \forsomeGuard{\gen}{\guard}		&\gmbox{for some}\\
       &\sugar& \guard_1\;\tl{,}\;\guard_2	&\gmbox{conjunction}\\
\rop &::=& \tl{<} \;|\; \tl{>} \;|\; \tl{=} \;|\; \tl{<=} \;|\; \tl{>=} &\\
\end{array}
\]
\[
\begin{array}{rcll}
\match &::=& \mrule\;\may{\tl{|}\;\match_2} &\\
\mrule &::=& \pat\;\tl{=>}\;\e &\\
\pat &::=& \tl{/}\nt{npat}\tl{/}		&\gmbox{nML pattern}\\
     & |& \tl{\char`\_}		&\gmbox{wild pattern}\\
     & |& \varid		&\gmbox{pattern var}\\
     & |& \braceExp{\patrow\; \may{\tl{...}}}  	&\gmbox{set pattern}\\
     & |& \braceExp{\pat_1\;\tl{...}\;\pat_2}	&\gmbox{interval set pattern}\\
     & |& \braceExp{\mpatrow\; \may{\tl{...}}}  &\gmbox{map pattern}\\
     & |& \injExp{\pat}{\ty}{\tl{1}|\tl{2}}	&\gmbox{injection pattern}\\
     & |& \tupleExp{\pat_1}{\pat_2} 	&\gmbox{tuple pattern}\\
     & |& \guardPat{\pat}{\guard}  &\gmbox{guarded pattern}\\
     & |& \orPat{\pat_1}{\pat_2}   &\gmbox{or pattern}\\
     & |& \coerceExp{\pat}{\ty}    &\\
     & |& \parenExp{\pat} &\\
     &\sugar& \constant   &\gmbox{const pattern}\\
     &\sugar& \tupleExp{\pat}{\patrow} 	&\gmbox{tuple pattern}\\
%     &\sugar& \braceExp{(\domid\;\tl{=>}\;\pat)\nt{row}
%                        \;\la\tl{...}\ra
%                       } & \gmbox{tuple pattern}\\
     &\sugar&\evalPat{\pat}{\e}		&\gmbox{eval pattern}\\
     &\sugar&\memberPat{\pat}{\e}	&\gmbox{member pattern}\\

\mpat &::=&\pat\;\tl{=>}\;\pat &
\end{array}
\]
\[
\begin{array}{rcll}
\semantics &::=&\valdec\;\may{\semantics} &\\
           &|&\eqndec\;\may{\semantics} &\\
%           &|&\semantics_1\;\semantics_2 &\\
\valdec&::=& \tl{val}\;\vbind	&\gmbox{auxiliary semantic value}\\
     &|&\tl{val rec}\;\vbind	&\gmbox{auxiliary semantic value}\\
     &\sugar&(\tl{fun}|\tl{map})\;\fbind	&\\
\vbind &::=& \pat\;\tl{=}\;\e\;\may{\tl{and}\;\vbind} &\\
\fbind &::=&
	 \varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	 \varid\;\pat\;\tl{=}\;\e &\\
       & & \may{\tl{and}\;\fbind} &\\
\eqndec&::=&\tl{eqn}\;\may{\tl{rec}}\;\ebind &\gmbox{semantic equation}\\
    &\sugar&\tl{eqn}\;\efbind &\\
\ebind &::=&\may{\kind}\;\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind} &\\
\efbind &::=&\kind\;\varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	 \varid\;\pat\;\tl{=}\;\e &\\
       & & \may{\tl{and}\;\efbind} &\\
\kind &::=& \nt{syntreekind}\;\nt{indexkind} &\\
      &\sugar&\nt{syntreekind} &\\
\nt{syntreekind} &::=& \tl{set}\;\setid\;\tl{:}\;\tl{syntree} &\\
\nt{indexkind} &::=&\tl{set}\;\setid\;\tl{:}\;\tl{index} &
\end{array}
\]
\[
\begin{array}{rcll}
\query&::=&\tl{spec}\;\ctlbind\;\may{\query} &\\
%      &|&\query_1\;\query_2 	&\\
\ctlbind &::=& \varid\;\tl{=}\;\ctl &\\
%      &|&\ctlbind_1\;\ctlbind_2 &\\
\ctl  &::=&\boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;\varid}
		    {\form}
	  &\gmbox{CTL formula with a binder}\\
       &|& \boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;\varid}
                    {\guard}
	  &\gmbox{CTL formula with a binder}\\
\form &::=& %\guard		&\gmbox{boolean expr}\\
         \varid_1\;\varid_2	&\gmbox{bind a ctl formula}\\
      &|&\tl{not}\;\form        &\\
      &|&\form_1\;\tl{and}\;\form_2 &\\
      &|&\form_1\;\tl{or}\;\form_2  &\\
      &|&\form_1\;\tl{->}\;\form_2  &\gmbox{implication}\\
      &|&\tl{A}\;\path		&\gmbox{for all paths}\\
      &|&\tl{E}\;\path		&\gmbox{for some path}\\
      &\sugar& \form_1\;\tl{<->}\;\form_2 &\gmbox{equivalence}\\
\path &::=&\tl{X}\;\ctl		&\gmbox{next}\\
      & |&\tl{F}\;\ctl		&\gmbox{future}\\
      & |&\tl{G}\;\ctl 		&\gmbox{always}\\
      & |&\ctl_1\;\tl{U}\;\ctl_2&\gmbox{until}\\
\end{array}
\]
%%%%%%%%%%%%%
\begin{tp}{Well-formedness}
Exists typing system such that
\textcolor{gray}{well-formed Rabbit specification gurantees to
transform into typeful nML programs}:

\NTheorem{Type Safety}{If $\notype{}{\spec}$ then
$\spec\hookrightarrow\nt{topdec}_{\nt{nML}}$ and
for an nML basis $B$, $B\vdash_{\nt{nML}}\nt{topdec}\Rightarrow B'$.}

\end{tp}
%%%%%%%%%%%%%
\begin{tp}{Interesting Problems}
\bi
\item checking for lattice
 \bi
 \item \textcolor{gray}{given partial orders between set elements}
 \ei
\item checking for monotonicity
 \bi
 \item \textcolor{gray}{only monotonic equations must be accepted}
 \ei
\item checking for distributivity
 \bi
 \item \textcolor{gray}{if distributive, an efficient fixpoint
 computation is possible}
 \ei
\ei
\end{tp}
%%%%%%%%%%%%%

\ed
