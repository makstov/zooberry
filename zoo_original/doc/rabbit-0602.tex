\documentclass{report}
\usepackage{proof,xspace,amsmath,latexsym,hangul}
\input{macroA}\input{macroB}\input{macroRabbit}
%\typein[\lang]{Language? (korean, english, bilingual)}
\let\language\korean
%\let\language\english

\title{프로그램 분석 시스템 {\bf 동물원}\\ Program Analysis System Zoo}
\author{
Kwangkeun Yi\\
Research On Program Analysis System\\
National Creative Research Initiative Center\\
{\tt ropas.kaist.ac.kr}\\
KAIST}
\date{\today}
\bd
\maketitle
\tableofcontents
%\chapter{\H{동기}{Motivation}}
%\bi
%\item \H{다양한 프로그램 분석기를 쉽게 구현하고 관리하게 해 주는
%         도구가 필요하다. 특히, nML 컴파일러 시스템에서 실제적으로
%         쓰일 수 있는.}  
%        {\\ We need a convenient tool to generate realistic yet
%ambitious program analyzers. We first aim it for being used in our LET
%project, in developing our nML compiler for FCC (fixpoint-carryincd-code).}
%\item \H{프로그램 분석기술을 산업 현장에 전달하는 가장 좋은 방법은
%         쓰기 편한 도구를 제공하는 것이다.}
%        {\\ The best way to transfer our program analysis technology to
%the industry is to provide them with a convenient high-level tool.}
%\ei
%
\chapter{\H{문법구조}{Syntax}}
\section{\H{문법}{Grammar}}
\H{다음의 표기법을 따른다:}{Notation:}
\[
\begin{array}{llcrl}
|	&\mbox{alternative} &\quad & () 	&\mbox{grouping}\\
\la\ra  &\mbox{optional}    &      & \bullet^* & \mbox{zero or more}\\
\bullet^+  &\mbox{one or more} &   & \dagger   &\mbox{sugared alternative}\\
\alpha\nt{row} &\lefteqn{\mbox{one or more $\alpha$'s separated by \tl{,}}}
\end{array}
\]
%\[
%\alpha\nt{row}\; ::=\; \alpha\;|\;\alpha\;\tl{,}\;\alpha\nt{row}
%\]
\[
\begin{array}{rcll}
\nt{integer} &::=& \la\tl{-}\ra(\tl{0}-\tl{9})^+  &\\
	     &|& (\tl{0X}|\tl{0x})
                 (\tl{0}-\tl{9}|\tl{A}-\tl{F}|\tl{a}-\tl{f})^+ &\\
             &|& (\tl{0O}|\tl{0o})(\tl{0}-\tl{7})^+ &\\
             &|& (\tl{0B}|\tl{0b})(\tl{0}-\tl{1})^+ &\\
%\nt{ignore}&::=&\tl{\char`\\}(\nt{newline}|\nt{formfeed}|
%                              \nt{newline}\:\nt{formfeed})
%	       (\nt{space}|\nt{tab})^+ &\\ 
\nt{comment} &::=& \lefteqn{\mbox{balanced \tl{(* *)}, between which
                                  any character can appear.}} &\\
             &| & \lefteqn{\mbox{from \tl{//} to the end of the line}} &\\
&&&\\
\nt{alphanum} &::=&  \tl{a}-\tl{z}\:|\:\tl{A}-\tl{Z}\:|\:\nt{hangul}
		\:|\:\tl{0}-\tl{9}\:|\:\tl{\char`\_}\:|\:\tl{'} & \\
\nt{upper} &::=& \tl{A}-\tl{Z}\:|\:\tl{\char`\_} &\\
\nt{lower} &::=& \tl{a}-\tl{z}\:|\:\nt{hangul} &\\
\nt{hangul} &::=& \lefteqn{
		   \mbox{syllables of KSX1001 (a.k.a. KSC5601 or eur-kr)}} \\
       & |&\lefteqn{\mbox{syllables of KSX1005-1
                          (a.k.a. KSC5700, unicode, or ISO/IEC10646-1)}}\\
\nt{sym} &::=& \lefteqn{
		\tl{!}\:|\:\tl{\%}\:|\:\tl{\char`\&}\:|\:\tl{\char`\$}
                \:|\:\tl{\char`\#}\:|\:\tl{+}\:|\:\tl{-}\:|\:\tl{/}\:|\:\tl{:}
		\:|\:\tl{<}\:|\:\tl{=}\:|\:\tl{>}\:|\:\tl{?}\:|\:\tl{@}\:|
		\:\tl{\char`\\}\:|\:\tl{\char`\~}\:|\:\tl{`}\:|
		\:\tl{\char`\^}\:|\:\tl{|}\:|\:\tl{*}
		}\\
%\end{array}
%\]
%\[
%\begin{array}{rcll}
\nt{lid} &::= &\nt{lower}(\nt{alphanum})^* & \\
\nt{uid} &::= &\nt{upper}(\nt{alphanum})^* & \\
\nt{sid} &::= & \nt{sym}\nt{sym}^+ &\\
\nt{id} &::= &\nt{lid}\;|\;\nt{uid}\;|\;\nt{sid} &\\
\varid &::=& \nt{id}	& \\
\ctlid &::=& \nt{id}	& \\
%\nt{prefixid} &::=& (\tl{!}\:|\:\tl{?}\:|\:\tl{\char`\~})\nt{sym}^* &\\
\elmtid&::=& \nt{id}	&\\
\setid&::=&  \nt{uid}	&\\
\latid&::=&  \nt{uid}	&\\
\domid&::=&  \setid\:|\:\latid	&\\
\anaid&::=& \nt{id} &\\
\sigid&::=& \nt{id} &\\
\temid&::=& \nt{id} &\\
\cvarid&::=& \nt{id} &\\
\conid&::=& \nt{id} &\\
\alpha\nt{longid} &::=&\alpha\nt{id}\;\;|\;\;\nt{anaid}.\alpha\nt{id} &\\
\end{array}
\]

\[
\begin{array}{rcll}
%\topdec &::=& \adec &\\
\topdec &::=& \anadec &\\
	&|& \sigdec &\\
	&|& \temdec &\\
	&|& \topdec_1\;\topdec_2 &\\
&&&\\
\adec &::=& \domdec &\\
	&|& \semdec &\\
	&|& \querydec &\\
	&|& \adec_1\;\adec_2 &\\
&&&\\
%\anadec &::=& \tl{analysis}\;\anabind &\\
%\anabind &::=& \anaid\;\tl{=}\;\anaexp &\\
\anadec &::=& \tl{analysis}\;\anaid\;\tl{=}\;\anaexp &\\
\anaexp &::=& \tl{ana}\;\adec\;\tl{end} &\\
	&|& \temid\;\tl{(}\anaexprow\tl{)} &\\
	&|& \anaid &\\
&&&\\
%\sigdec &::=& \tl{signature}\;\sigbind &\\
%\sigbind &::=& \sigid\;\tl{=}\;\sigexp &\\
\sigdec &::=& \tl{signature}\;\sigid\;\tl{=}\;\sigexp &\\
\sigexp &::=& \tl{sig}\;\adesc\;\tl{end} &\\
	&|& \sigid &\\
&&&\\
%\temdec &::=&\tl{analysis}\;\tembind &\\
%\tembind &::=&\temid\tl{(}(\anaid\;\tl{:}\;\sigexp)\nt{row}\tl{)}\;
%		\tl{=}\;\tl{ana}\;\adec\;\tl{end} &\\
\temdec &::=&\tl{analysis}\;
                \temid\tl{(}(\anaid\;\tl{:}\;\sigexp)\nt{row}\tl{)}\;
		\tl{=}\;%\tl{ana}\;\adec\;\tl{end} &\\
                        \anaexp &\\
&&&\\
\adesc
&::=&\tl{set}\;\setdesc &\\
 &|& \tl{lattice}\;\latdesc &\\
 &|& \tl{val}\;\varid\;\tl{:}\;\ty &\\
 &|& \tl{eqn}\;\varid\;\tl{:}\;\ty &\\
 &|& \tl{query}\;\ctlid\;\tl{:}\;\ty &\\
 &|& \adesc_1\;\adesc_2 &\\
 &\sugar&\tl{set}\;\setdesc\nt{row} &\\
 &\sugar&\tl{lattice}\;\setdesc\nt{row} &\\
\setdesc &::=& \setid\;\;|\;\;\kindIt{\setid}{\kind}\;\;|\;\;\setbind &\\
\latdesc &::=& \latid\;\;|\;\;\kindIt{\latid}{\kind}\;\;|\;\;\latbind &\\

\end{array}
\]
\[
\begin{array}{rcll}
\domdec &::=& \setdec\;|\;\latdec\;|\;\widendec &\\
%	&|& \domdec_1\;\domdec_2 &\\
\setdec &::=& \tl{set}\;\setbind &\\
%        &|& \setdec_1\;\setdec_2 &\\
\setbind &::=& \setid\;\tl{=}\;\setexp &\\
\setexp
 &::=&\tl{/}\nt{tylongid}\tl{/}\;|\;\tl{/}\nt{strlongid}\tl{/}
     &\mbox{nML type/structure id}\\
 &|&\setlongid				& \mbox{set id}\\
 &|&\braceExp{\eO\;\tl{...}\;\eT}	& \mbox{integer interval set}\\
 &|&\braceExp{\elmtidrow} 		& \mbox{enumerated set}\\
 &|&\tl{power}\;\setexp 		& \mbox{power set}\\
 &|&\setexp_1\;\tl{*}\;\setexp_2	& \mbox{cartesian product}\\
 &|&\setexp_1\;\tl{+}\;\setexp_2	& \mbox{separated sum}\\
 &|&\setexp_1\;\tl{->}\;\setexp_2	& \mbox{finite function set}\\
 &|&\setexp\;\tl{constraint}\;\cnstdec	& \mbox{constraint set}\\
 &|&\parenIt{\setexp}	&\\
\cnstdec &::=& \tl{var = }\braceExp{\cvaridrow}\;\may{\tl{index}\;\setexp}&\\
         &   & \tl{rhs = }\rhs &\\
% \cnstdec &::=& \cvarid\;\may{\tl{index}\;\setexp}\;\tl{<-}\;\rhs
% 		\;\may{\tl{and}\;\cnstdec} 	&\\
%\rhs &::=&\cvar\;\may{\tl{|}\;\rhs} &\\
%     &|& \conid\;\may{\carg}\;\may{\tl{:}\;\tl{atomic}}
%	       \;\may{\tl{|}\;\rhs}		&\\
\rhs &::=&\cvar &\\
      &|& \conid\;\may{\carg}\;\may{\tl{:}\;\tl{atomic}} &\\
      &|&\rhs_1\;\tl{|}\;\rhs_2 &\\
\cvar &::=&\tl{var}\;|\;\tl{var}\;\setlongid &\\
\carg &::=&\cvar &\\
      &|& \setexp &\\
      &|& \tl{(}\;\cargrow\;\tl{)} &\\
 &&&\\
\latdec &::=&\tl{lattice}\;\latbind &\\
%        &|& \latdec_1\;\latdec_2 &\\
\latbind&::= &\latid\;\tl{=}\;\latexp &\\
\latexp &::=&\tl{/}\nt{strlongid}\tl{/} & \mbox{nML structure id}\\
  &|&\latlongid			 & \mbox{lattice id}\\
  &|&\tl{flat}\;\setexp          & \mbox{flat lattice}\\
  &|&\tl{power}\;\setexp         & \mbox{powerset lattice}\\
  &|&\latexp_1\;\tl{*}\;\latexp_2  & \mbox{cartesian product}\\
  &|&\latexp_1\;\tl{+}\;\latexp_2  & \mbox{coalesced sum}\\       
  &|&\latexp_1\;\tl{->}\;\latexp_2 & \mbox{atomic function lattice}\\
  &|&\setexp\;\tl{->}\;\latexp & \mbox{dependent product lattice}\\
  &|&\setexp\;\tl{order}\;\nt{order} &\mbox{lattice with explicit orders}\\
  &|&\parenIt{\latexp}	&\\
\nt{order}&::=& \nt{po}\;\nt{pat} &\mbox{chain}\\
          &|& \nt{order}_1\;\tl{|}\;\nt{order}_2\\
          &\sugar& \nt{pat}\;(\nt{po}\;\nt{pat})^+ &\\
\nt{po} &::=&\tl{<}\;\; |\;\;\tl{>} &\mbox{partial order}\\
&&&\\
\widendec &::=&\tl{widen}\;\latid\;\tl{with}\;\match &\\
&&&\\
\kind &::=&\tl{syntree}\;|\;\tl{index}\;|\;\tl{integer}\;|\;\tl{power}&\\
      & | &\tl{sum}\;|\;\tl{product}\;|\;\tl{arrow}&\\
\end{array}
\]
\[
\begin{array}{rcll}
\semdec &::=&\valdec &\\
          &|&\eqndec &\\
          &|&\ccrdec &\\
          &|&\cimdec &\\
%	  &|&\semdec_1\;\semdec_2 &\\
&&&\\
\valdec&::=& \tl{val}\;\vbind	&\mbox{auxiliary semantic value}\\
     &|&\tl{val rec}\;\vbind	&\mbox{auxiliary semantic value}\\
     &\sugar&\tl{fun}\;\fbind	&\\
     &\sugar&\tl{map}\;\fbind 	&\\
\vbind &::=& \pat\;\tl{=}\;\e\;\may{\tl{and}\;\vbind} &\\
\fbind &::=&
	 \varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	 \varid\;\pat\;\tl{=}\;\e &\\
       & & \may{\tl{and}\;\fbind} &\\
&&&\\      
\eqndec&::=&\tl{eqn}\;\ebind &\mbox{semantic equation}\\
         &|&\tl{eqn rec}\;\ebind &\mbox{semantic equation}\\
    &\sugar&\tl{eqn}\;\efbind &\\
\ebind  &::=&\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind} &\\
\efbind &::=&\varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	     \varid\;\pat\;\tl{=}\;\e &\\
        &   &\may{\tl{and}\;\efbind} &\\
&&&\\
\ccrdec &::=&\tl{ccr}\;\ccrbind & \mbox{constraint closure rule}\\
\ccrbind &::=&\cnstguard\;\tl{--}^+\;\constraintrow\;\may{\tl{|}\;\ccrbind} &\\
\cnstguard &::=& \constraint &\\
           & | & \guard &\\
           & | & \cnstguard_1\;\tl{,}\;\cnstguard_2 &\\
\constraint &::=& \cvarexp\;\tl{<-}\;\rhsexp &\\
	&\sugar&  \cvarexp\;\tl{<-}\;\rhsexp\;(\tl{+}\;\rhsexp)^+ &\\
\rhsexp &::=&\cvarexp &\\
        &|& \conlongid\;\may{\cargexp} &\\
\cargexp &::=& \cvarexp &\\
      &|& \pat &\\
      &|& \tl{(}\;\cargexprow\;\tl{)} &\\
\cvarexp &::=& \cvarlongid\;|\;\indexExp{\cvarlongid}{\pat} &\\
&&&\\
\cimdec &::=&\tl{cim}\;\cimbind
        &\mbox{constraint conid's image declaration}\\
\cimbind &::=& \conlongid\;\may{pat}\;\tl{=}\;\e\;\may{\tl{|}\;\cimbind} &\\
%\ebind  &::=&\may{\kind}\;\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind} &\\
%\efbind &::=&\may{\kind}\;\varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
%	     \varid\;\pat\;\tl{=}\;\e &\\
%        &   &\may{\tl{and}\;\efbind} &\\
%\kind &::=& \nt{syntreekind}\;\nt{indexkind} &\\
%      &|&\nt{indexkind}\;\nt{syntreekind} &\\
%      &|&\parenIt{\kind} &\\
%      &\sugar&\nt{syntreekind} &\\
%\nt{syntreekind} &::=& \tl{set}\;\setid\;\tl{:}\;\tl{syntree} &\\
%\nt{indexkind} &::=&\tl{set}\;\setid\;\tl{:}\;\tl{index} &
\end{array}
\]
\[
\begin{array}{rcll}
\e&::=& \tl{/}\m{\nt{nmlexp}}\tl{/}	&\mbox{embedded nML expr}\\
 & |& \setlongid      		&\mbox{set itself}\\
 & |& \constant			&\mbox{constant}\\
 & |& \varlongid		&\mbox{bound id}\\
 & |& \constraint		&\mbox{constraint}\\
 & |& \eO\;\bop\;\eT 		&\mbox{binary op}\\
 & |& \braceExp{\eO\;\tl{...}\;\eT} 		& \mbox{integer set}\\
 & |& \braceExp{\erow}		&\mbox{set}\\
 & |& \setcomExp{\erow}{\qual}	&\mbox{set comprehension}\\
 & |& \braceExp{\mrulerow}      &\mbox{map}\\
 & |& \setcomExp{\mrulerow}{\qual} &\mbox{map comprehension}\\
 & |& \tl{\char`\{\char`\}}	&\mbox{empty set/map}\\
 & |& \foldExp{\tl{+}}{\e}      &\mbox{fold join}\\
 & |& \foldExp{\tl{*}}{\e}      &\mbox{fold meet}\\
 & |& \tupleExp{\e_1}{\e_2}	&\mbox{tuple}\\ 
 & |& \projExp{\e}{\tl{1}}\;\;|\;\;\projExp{\e}{\tl{2}}	&\mbox{projection}\\ 
 & |& \injExp{\e}{\ty}{\tl{1}}\;\;|\;\;\injExp{\e}{\ty}{\tl{2}} 
							&\mbox{injection}\\
 & |& \letExp{\valdec}{\e}	&\mbox{local expr}\\
 & |& \fnExp{\match}		&\mbox{abstraction}\\
 & |& \appExp{\eO}{\eT} 	&\mbox{application or map image}\\
 & |& \parenExp{\e}		&\\
 & |& \coerceExp{\e}{\ty}	&\mbox{coercion}\\
 & |& \indexExp{\may{\tl{pre}\:|\:\tl{post}}\;(\varlongid|\cvarlongid)}{e} 
	&\mbox{solution look-up}\\
% & |& \solutionExp{\tl{post}\;\varlongid}{e} &\mbox{solution look-up}\\
 &\sugar&\tupleExp{\e}{\erow}	&\mbox{tuple}\\
 &\sugar&\projExp{\e}{\domlongid}	&\mbox{projection}\\
 &\sugar&\modiExp{\e}{\mrule}	&\mbox{modifying map}\\
% &\sugar&\modiExp{\eO}{\domid\;\tl{=>}\;\eT} &\mbox{modifying tuple}\\
 &\sugar&\mpExp{\match} 	&\mbox{map}\\
 &\sugar&\caseExp{\e}{\match} 	&\mbox{branch}\\
 &\sugar&\ifExp{\eO}{\eT}{\eR} &\mbox{branch}\\
 &\sugar&\mapExp{\eO}{\eT} &\mbox{mapping}\\
\bop &::= & \tl{+}\;|\;\tl{*}\;|\;\tl{-} &\mbox{join, meet, set-minus}\\
     &|&    \rop 			 &\mbox{relational operators}\\
\constant &::=& \nt{integer}   	&\\
 &|&\elmtlongid		&\mbox{set element id}\\
 &|&\tl{top}		&\mbox{lattice top}\\
 &|&\tl{\char`\^}	&\mbox{lattice top}\\
 &|&\tl{bottom}		&\mbox{lattice bottom}\\
 &|&\tl{\char`\_\char`\_}	&\mbox{lattice bottom}\\
 &|&\tl{true}	&\\
 &|&\tl{false}	&\\
%\nt{ne} &::=& \rabbitId{\varlongid}	&\mbox{embedded rabbit id}\\
%        &|&   \nt{nmlexp} &\mbox{nML expr with embedded rabbit id}\\
\ty &::=&\tl{int}\;|\;\domlongid\;|\;\tl{/}\nt{tylongid}\tl{/} &\\
    & | &\ty_1\;\tl{*}\;\ty_2\;|\;\ty_1\;\tl{+}\;\ty_2 &\\
    & | &\ty_1\;\tl{->}\;\ty_2\;|\;\tl{power}\;\ty &\\
    & | &\parenIt{\ty} &\\
    & | &\kindIt{\ty}{\kind} &\\
%    & | &\parenExp{\ty\;\tl{,}\;\tl{1}}\;|\;\parenExp{\ty\;\tl{,}\;\tl{2}}&
\end{array}
\]
\[
\begin{array}{rcll}
\qual &::=& \gen\;\may{\tl{,}\;\guard} &\\
\gen &::=&\genPat{\pat}{\e}        &\mbox{for each element of a set}\\
     &|&\genPat{\mpat}{\e}  &\mbox{for each entry of a map}\\
     &|&\gen_1\;\tl{,}\;\gen_2 &\\
\guard &::=&\eO\;\rop\;\eT	   	 &\mbox{relation}\\
       & |& \eO\;\tl{in}\;\eT		 &\mbox{membership}\\
       & |& \tl{not}\;\guard		 &\\
       & |& \guard_1\;\tl{and}\;\guard_2 &\\
       & |& \guard_1\;\tl{or}\;\guard_2  &\\
       & |& \forallGuard{\gen}{\guard}		&\mbox{for all}\\
       & |& \forsomeGuard{\gen}{\guard}		&\mbox{for some}\\
       & |& \parenIt{\guard}		&\\
       &\sugar& \guardrow	&\mbox{conjunction}\\
\rop &::=& \tl{<} \;|\; \tl{>} \;|\; \tl{=} \;|\; \tl{<=} \;|\; \tl{>=} &\\
&&&\\
\match &::=& \mrule\;\may{\tl{|}\;\match} &\\
\mrule &::=& \pat\;\tl{=>}\;\e &\\
\pat &::=& \tl{/}\nt{npat}\tl{/}		&\mbox{nML pattern}\\
     & |& \tl{\char`\_}		&\mbox{wild pattern}\\
     & |& \varid		&\mbox{pattern var}\\
     & |& \braceExp{\patrow\; \may{\tl{...}}}  	&\mbox{set pattern}\\
     & |& \braceExp{\pat_1\;\tl{...}\;\pat_2}	&\mbox{interval set pattern}\\
     & |& \braceExp{\mpatrow\; \may{\tl{...}}}  &\mbox{map pattern}\\
     & |& \injExp{\pat}{\ty}{\tl{1}|\tl{2}}	&\mbox{injection pattern}\\
     & |& \tupleExp{\pat_1}{\pat_2} 	&\mbox{tuple pattern}\\
     & |& \guardPat{\pat}{\guard}  &\mbox{guarded pattern}\\
     & |& \orPat{\pat_1}{\pat_2}   &\mbox{or pattern}\\
     & |& \asPat{\varid}{\pat}     &\mbox{as pattern}\\
     & |& \coerceExp{\pat}{\ty}    &\\
     & |& \parenIt{\pat} &\\
     &\sugar& \constant   &\mbox{const pattern}\\
     &\sugar& \tupleExp{\pat}{\patrow} 	&\mbox{tuple pattern}\\
%     &\sugar& \braceExp{(\domid\;\tl{=>}\;\pat)\nt{row}
%                        \;\la\tl{...}\ra
%                       } & \mbox{tuple pattern}\\
     &\sugar&\ropPat{\pat}{\e}		&\mbox{relation pattern}\\
     &\sugar&\memberPat{\pat}{\e}	&\mbox{member pattern}\\

\mpat &::=&\pat\;\tl{=>}\;\pat &
\end{array}
\]
\[
\begin{array}{rcll}
\querydec&::=&\tl{query}\;\ctlbind&\\
\ctlbind &::=& \ctlid\;\tl{=}\;\ctl\;\may{\tl{and}\;\ctlbind}&\\
\ctl  &::=&\boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;\varid}
		    {(\form|\guard)}
	  &\mbox{CTL formula with a binder}\\
       &|& \boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;
                     \tl{(}\anaid\tl{.}\varid\tl{)}}
                    {(\form|\guard)}
	  &\mbox{CTL formula with a binder}\\
       &|& \parenIt{\ctl} &\\
\form &::=& \ctlid\;\varid	&\mbox{ctl application}\\
      &|&\tl{not}\;\form        &\\
      &|&\form_1\;\tl{and}\;\form_2 &\\
      &|&\form_1\;\tl{or}\;\form_2  &\\
      &|&\form_1\;\tl{->}\;\form_2  &\mbox{implication}\\
      &|&\nt{u}\path\;\ctl		&\mbox{unary path formula}\\
      &|&\nt{b}\path\;\parenIt{\ctl_1\;\tl{,}\;\ctl_2} &\mbox{binary path formula}\\
      &|&\parenIt{\form}	&\\
      &\sugar& \form_1\;\tl{<->}\;\form_2 &\mbox{equivalence}\\
\nt{u}\path &::=&\tl{AX}\;|\;\tl{AF}\;|\;\tl{AG} &\\
      & | &\tl{EX}\;|\;\tl{EF}\;|\;\tl{EG} &\\
\nt{b}\path &::=&\tl{AU}\;|\;\tl{EU} &\mbox{until}
\end{array}
\]
\newpage
\section{\H{설탕 구조}{Syntactic Sugars}}
\H{자유로운 이름이 설탕이 녹으면서 묶이지 않도록 한다.}
{Free identifiers must not be bound in the de-sugar'ed definitions.}
\[
\begin{array}{lcll}
\lefteqn{\tl{set}\;\setdesc_1\tl{,}\cdots\tl{,}\setdesc_n}\\
&\equiv& \lefteqn{
         \tl{set}\;\setdesc_1\;\cdots\;\tl{set}\;\setdesc_n
         }\\
\lefteqn{\tl{lattice}\;\latdesc_1\tl{,}\cdots\tl{,}\latdesc_n}\\
&\equiv& \lefteqn{
         \tl{lattice}\;\latdesc_1\;\cdots\;\tl{lattice}\;\latdesc_n
         }\\
%\lefteqn{Order}\\
\nt{pat}\;\nt{po}_1\;\nt{pat}_1\cdots\nt{po}_n\;\nt{pat}_n
&\equiv& \lefteqn{
         \nt{po}_1\;\parenIt{\nt{pat}\tl{,}\nt{pat}_1}\;\tl{|}\cdots\tl{|}\;
         \nt{po}_n\;\parenIt{\nt{pat}_{n-1}\tl{,}\nt{pat}_n}
         }
\\
%\lefteqn{Expression}\\
\parenIt{\e_1\tl{,} \e_2\tl{,} \e_3}
&\equiv& \parenIt{\e_1\tl{,}\parenIt{\e_2\tl{,} \e_3}} &
\\
\projExp{\e}{\domid}
&\equiv& \projExp{\e}{\tl{k}} &
 \mbox{$\e: D=A_1\times\cdots\times A_n$ and $\domid = A_k$}
\\
\modiExp{\e}{\pat\;\tl{=>}\;\e'}
&\equiv&\braceExp{\pat\;\tl{=>}\;\e'\;\tl{,}\;\tl{x}\;\tl{=>}\;\e\:\tl{x}} &
 \mbox{new \tl{x}}
\\
\mpExp{\mrule_1\;\tl{|}\cdots\tl{|}\;\mrule_n}
&\equiv&\braceExp{\mrule_1\;\tl{,}\cdots\tl{,}\;\mrule_n} &
\\
\caseExp{\e}{\match} &\equiv&\parenIt{\fnExp{\match}}\;\e &
\\
\ifExp{\eO}{\eT}{\eR} &\equiv&\lefteqn{
\caseExp{\eO}{\tl{true}\;\tl{=>}\;\eT\;\tl{|}\;\tl{false}\;\tl{=>}\;\eR}
}
\\
\mapExp{\eO}{\eT} &\equiv&\lefteqn{
\setcomExp{\eO\;\tl{x}}{\genPat{\tl{x}}{\eT}}
}
\\
\guard_1\;\tl{,}\;\guard_2 &\equiv&\guard_1\;\tl{and}\;\guard_2 &
\\
\cvarexp\;\tl{<-}\;\rhsexp_1\;\tl{+}\;\rhsexp_2 &\equiv&\lefteqn{
\cvarexp\;\tl{<-}\;\rhsexp_1\;\tl{,}\;\cvarexp\;\tl{<-}\;\rhsexp_2}
\\
%\lefteqn{Pattern}\\
\tupleExp{\pat_1}{\pat_2\;\tl{,}\;\pat_3}
&\equiv&\tupleExp{\pat_1}{\tupleExp{\pat_2}{\pat_3}} &
\\
\constant &\equiv & \guardPat{\tl{x}}{\tl{x = }\constant} &
\mbox{new \tl{x}}
\\
\ropPat{\pat}{\e} &\equiv&\guardPat{\asPat{\tl{x}}{\pat}}{\tl{x}\;\rop\;\e} &
\mbox{new \tl{x}}
\\
\memberPat{\pat}{\e}&\equiv&\guardPat{\asPat{\tl{x}}{\pat}}{\tl{x in \e}} &
\mbox{new \tl{x}}
\\
%\lefteqn{Declaration}\\
\lefteqn{
\tl{fun}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
          \tl{val rec}\;\varid\;\tl{= fn}\;
          \pat_1\;\tl{=>}\;\e_1\;\tl{|}\;\pat_2\;\tl{=>}\;\e_2
        }
}
\\
\lefteqn{
\tl{map}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
         \tl{val}\;\varid\;\tl{=}\;
         \braceExp{\pat_1\;\tl{=>}\;\e_1\;\tl{,}\;\pat_2\;\tl{=>}\;\e_2}
         }
}
\\
\lefteqn{
\tl{eqn}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
          \tl{eqn rec}\;\varid\;\tl{= fn}\;
          \pat_1\;\tl{=>}\;\e_1 \;\tl{|}\;\pat_2\;\tl{=>}\;\e_2
        }
}
\\
%%\lefteqn{Kind}\\
%\tl{set}\;\setid\;\tl{:}\;\tl{syntree}
%&\equiv& \lefteqn{
%          \tl{set}\;\setid\;\tl{:}\;\tl{syntree}\;
%          \tl{set}\;\setid\;\tl{:}\;\tl{index}
%         } &
%\\
%\lefteqn{CTL Formula}\\
\form_1\;\tl{<->}\;\form_2
&\equiv&\lefteqn{
         \form_1\;\tl{->}\;\form_2\;\tl{and}\;
         \form_2\;\tl{->}\;\form_1
        } &
\\
\end{array}
\]

%\section{\H{기본 타입과 연산자}{Primitive Types and Operators}}
%\bi
%\item \H{기본 타입}{Primitive types}:
%\tl{int}, \tl{bool}
%\item \H{기본 연산자}{Primitive operators}:
%
%\begin{tabular}{|r|l|l|}\hline
%\tl{+},\tl{-},\tl{*},\tl{/}
%     & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int add/sub/mul/div\\
%%\tl{+} & (prefix) $\tl{int}\to\tl{int}$ & identity\\
%%\tl{-} & (prefix) $\tl{int}\to\tl{int}$ & int negation\\
%%       & (prefix) $\tl{real}\to\tl{real}$ & real negation\\
%\tl{div} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int division\\
%\tl{mod} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int modulus\\
%\tl{**} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int exponential\\
%\hline
%\end{tabular}
%
%\ei
%
\section{\H{우선순위와 방향성}{Precedences and Associativity}}
\bi
\item \H{도메인 식에서의 우선순위(내림차순)와 방향성}
  {Constructs' precedence (in decreasing order) and associativity}

 \begin{tabular}{|l|c|}  \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{order}$ & -- \\ \hline
 $\tl{power},\tl{flat}$ & right \\ \hline
 $\tl{*}$ & left \\ \hline
 $\tl{+}$ & left \\ \hline
 $\tl{->}$ & right \\ \hline
 \end{tabular}

\item \H{분석 식에서의 우선순위(내림차순)와 방향성}
  {Constructs' precedence (in decreasing order) and associativity}

 \begin{tabular}{|l|c|}  \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 \tl{@} & left \\ \hline
 $\tl{.}$ & left \\ \hline
 $\tl{[}\mrule\tl{]}$ & left \\ \hline
 application & left \\ \hline
 $\tl{+}$ (prefix), $\tl{*}$ (prefix) & right \\ \hline
 $\tl{*}$ (infix) & left \\ \hline
 $\tl{+}$ (infix), $\tl{-}$ (infix) & left \\ \hline
 $\tl{<}$,$\tl{>}$,$\tl{=}$,$\tl{<=}$,$\tl{>=}$ & left \\ \hline
 $\tl{not}$ & right \\ \hline
 $\tl{and}$ & right \\ \hline
 $\tl{or}$  & right \\ \hline
 $\tl{in}$ & right \\ \hline
 $\tl{,}$ & left \\ \hline
 $\tl{:}$ & left \\ \hline
 $\tl{case}$, $\tl{fn}$, $\tl{mp}$ & right \\ \hline
 \end{tabular}

\item
\H{패턴에서의 우선순위(내림차순)와 방향성}
  {Pattern constructs' precedence (from higher to lower) and associativity}

 \begin{tabular}{|l|c|} \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{:}$ & left \\ \hline
 $\tl{as}$ & left \\ \hline
 $\tl{with}$ & left \\ \hline 
 \end{tabular}

\item
\H{탐색 식에서의 우선순위(내림차순)와 방향성}
  {CTL formula constructs' precedence (from higher to lower) and associativity}

 \begin{tabular}{|l|c|} \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{not}$ & right \\ \hline
 $\tl{and}$ & left \\ \hline
 $\tl{or}$ & left \\ \hline
 $\tl{->}$ & left \\ \hline
 ($\tl{A}|\tl{E}|\tl{U}$)($\tl{X}|\tl{F}|\tl{G}$) & right \\ \hline
 \end{tabular}

\ei

\section{\H{예약된 심볼들}{Reserved words}}
\begin{verbatim}

analysis  ana  end  signature  sig   set  lattice  atomic  val  eqn  query 
power  constraint  index  var  rhs  flat  order  widen  with  syntree  index  
integer sum  product  arrow  val  rec  fun  map  ccr  cim  and  pre  post 
top  bottom  true false int  not  or  let  fn  mp  case  of  as  from  widen
AX  AF  AG  AU  EX  EF  EG  EU  (  )  :  |  {  }  ...  *  +  ->  <- <  >  [  ]
=>  _  !  ?  .  ,  =  <=  >=  <->  @  ^  __ 
\end{verbatim}


\section{\H{문법적인 제약들}{Syntactic Constraints}}
\bi

\item \H{as-패턴과 with-패턴이 녹을 수 있는 설탕이기 위해서는 패턴이 
계산식(expression)의 형태를 가지고 있어야 한다. 예를들어,
\tl{\char`\_}(wildcard)가 패턴에 있으면 않된다.}
{No wildcard pattern is allowed in both the \tl{as}-pattern and
\tl{with}-pattern. Because the patterns must be legal as expressions.} 

\item \H{제약식 선언($\cnstdec$)에서 선언되는 제약식
함수심볼($\conid$)들과 제약식 변수($\cvarid$)들은 모두 달라야 한다.}
{In a constraint set declaration, every constraint function symbol
$\conid$ and constraint variable $\cvarid$ must be distinct.}

\item \H{제약식 푸는 규칙($\ccrdec$)에서 하나의
제약식($\constraint$)이나 조건절($\guard$)에서 사용되는 패턴 변수들은
모두 달라야 한다.}{For a constraint closure rule ($\ccrdec$), every
pattern variable in each constraint or guard must be distinct.}

\ei


\chapter{\H{프로그램 분석의 기획}{Well-formed Specification for
Program Analysis}}
\[
\begin{array}{rrcl}
\nt{Type}&\t &::=& 
	\nt{int}\;|\;\nt{bool}\;|\;\St\;|\;\Lt
  \;|\;\t_1\times\t_2\;|\;\t_1+\t_2\;|\;\t_1\to\t_2\;|\;\power{\t}
  \;|\;\nt{ty}_{nML}\;|\;\kindIt{\t}{\kappa}\\
\nt{Set} &\St &::=& \intervalset
              \;|\;\{\elmtidrow\}\;|\;\power{\St} \\
	 &&|& \St_1\times\St_2\;|\;\St_1+\St_2
         \;|\;\St_1\mapsto\St_2 \\
	 &&|& \nt{tylongid}_{\nt{nML}} \\
\nt{Lattice} &\Lt &::=& %\nt{strlongid}_{nML}\;|\;
	 \flat{\St}\;|\;\ordered{\St}\;|\;\power{\St} \\
	 &&|& \Lt_1\times\Lt_2\;|\;\Lt_1+\Lt_2
	 \;|\;\Lt_1\mapsto\Lt_2\;|\;\St\mapsto\Lt \\
         &&|& \nt{strlongid}_{\nt{nML}} \\
\nt{Kind} &\kappa&::=&\nt{index}\;|\;\nt{syntree}\;|\;\nt{integer}
     \;|\;\nt{power}\;|\;\nt{sum}\;|\;\nt{product}\;|\;\nt{arrow}
     \;|\;\cdot\\
\end{array}
\]
\[
\begin{array}{rcrcl}
  &&\nt{Pre} &=&\nt{Type}\cup\{\cdot\} \\
  &&\nt{Post} &=&\nt{Type} \\
  &&\nt{Syntree} &=&\nt{Set}\cup\{\cdot\} \\
  &&\nt{Index} &=&\nt{Set}\cup\{\cdot\} \\
\mbox{$p$ or $(\St_1,\St_2)$} &\in&
 \nt{Pivot}&=&\nt{Syntree}\times\nt{Index}\\
(\t_1,\t_2,p)&\in&\nt{EqnType}&=&\nt{Pre}\times\nt{Post}\times\nt{Pivot}\\
\VE &\in& \nt{VarEnv} &=&
          \nt{VarId}\finmap\nt{Type}\cup\nt{EqnType}\\%\cup\nt{CnstType}\\
\CE &\in&\nt{CnstEnv} &=& \nt{CvarEnv}\times\nt{ConEnv} \\
\CV &\in&\nt{CvarEnv} &=& \nt{CvarId}\finmap\nt{Set}
			\cup\nt{Set}\times\nt{Index}\\
\CN &\in&\nt{ConEnv} &=& \nt{ConId}\finmap\nt{Type} \\
\SE &\in& \nt{SetEnv} &=& \nt{SetId}\finmap\nt{Set}\cup\nt{Kind} \\
\LE &\in& \nt{LatEnv} &=& \nt{LatId}\finmap\nt{Lattice}\cup\nt{Kind} \\
\mbox{$\E$ or $(\VE,\SE,\LE,\CE)$}\;
    &\in& \nt{Env}&=&\nt{VarEnv}\times\nt{SetEnv}\times\nt{LatEnv}
		     \times\nt{CnstEnv} \\
&&&&\\
\AE &\in& \nt{AnaEnv}&=&\nt{AnaId}\finmap\nt{Env}\\
\GE &\in&\nt{SigEnv}&=&\nt{SigId}\finmap\nt{Env}\\
\TE &\in&\nt{TemEnv}&=&\nt{TemId}\finmap\nt{ParamEnv}\times\nt{Env}\\
    &   &\nt{ParamEnv}&=&\cup_{k\geq1}(\nt{AnaId}\times\nt{Env})^k\\
C &\in&\nt{Context}&=&\nt{AnaEnv}\times\nt{SigEnv}
		\times\nt{TemEnv}\times\nt{Env}
\end{array}
\]

\bi
\item[$A\finmap B$:]
  \H{집합 A의 유한한 부분집합에서 집합 B로 가는 함수들의 집합.}
    {The set of functions from finite subsets of $A$ into $B$.}

\item[{$\may{}$}:]
 \H{의미구조의 규칙에서도 $\may{}$는 문법구조에서 처럼, 덧 붙일 수
 있는 것을 표현한다. 예를들어,
  \[
  \begin{array}{c}
  \infer{C\;\may{D}}{A\;\may{B}}
  \end{array}
  \]
  는 다음의 두가지 규칙을 의미한다:
  \[
  \begin{array}{c}
  \infer{C}{A}\quad\quad
  \infer{C\;D}{A\; B}
  \end{array}
  \]
 }{Optional case.}

\item[{$a/b$}:]
 \H{``$a/b$''는 ``$a$ 혹은 $b$''를 표현한다. 여러뭉치가 사용될 때는
  앞의 것은 앞의 것 끼리, 뒤에 것은 뒤에 것끼리 있는 것을
  표현한다. 예를들어,
  \[
  \begin{array}{c}
  \infer{B\;a/b}{A\;a'/b'}
  \end{array}
  \]
  는 다음의 두가지 규칙을 의미한다:
  \[
  \begin{array}{c}
  \infer{B\;a}{A\;a'}\quad\quad
  \infer{B\;b}{A\;b'}
  \end{array}
  \]
 }{Alternative case. The correspondence is implied.}

\item[{$f+g$}:]
 \H{``$f+\entry{x}{y}$''는 함수 $f$의 정의영역에서 $x$ 엔트리를
 $y$로 바꾸거나 ($x\in\dom{f}$인 경우) 확장한다 ($x\not\in\dom{f}$인 경우).
 일반적으로 ``$f+g$''는 함수 $g$가 함수 $f$를 바꾸거나 확장하는 것인데, 
 필요하면 $g$를 $f$의 타입 $A$로 확장시킨 후에 ($\coerce{g}{A}$)
 정의되는 것으로 한다.
 }{Overshadow $f$ by $g$. If $f$ is a tuple and $g$ is of its one
component type, other components of $f$ is intact.}

\item[{$\coerce{g}{A}$}:]
 \H{``$\coerce{g}{A}$''는 $G$의 원소 $g$를 $A$의 원소로 만드는데, 이
  때 $A$의 원소가 가져야 하는 부품은 공집합으로 한다. 예를들어,
  $A = G\times H$이고 $H = X\finmap Y$일 때 ``$\coerce{g}{A}$''는 ``$\la
  g,\{\}\ra$''를 뜻한다.
 }{It denotes an element of a product set $A$ that is made from
$g$. For exampel, if $A = G\times H$ and $H = X\finmap Y$,
``$\coerce{g}{A}$'' denotes ``$\la  g,\{\}\ra$.''}

\item[$\of{A}{B}$:]
 \H{``$\of{A}{B}$'' 는 $B$가 $(\cdots,A,\cdots)$일때 $A$를 뜻한다.}
   {When $B = (\cdots,A,\cdots)$, ``$\of{A}{B}$'' denotes $A$.}

\item[$\t\setminus\t'$:]
 \H{곱(product) 타입 $\t$에서 $\t'$을 뺀 결과 타입을 뜻한다. 
    아무 타입도 남지않으면 $\cdot$을 남긴다.}
   {It denotes the type that results from removing $\t'$ component
from a product type $\t$. When nothing is left, it denotes ``empty
type'' $\cdot$.}

\item[$\t'\in\t$:]
 \H{곱(product) 타입 $\t$에서 $\t'$을 부품으로 가지고 있으면 참,
    아니면 거짓이다.}
   {True if $\t'$ is a component type of a product type $\t$, false otherwise.}

\item[$C_\beta(\alpha\nt{longid})$:]
 \[
 \begin{array}{rcl}
 C_\beta(\alpha\nt{id}) &=& (\of{\beta}{(\of{E}{C})})(\alpha\nt{id})\\
 C_\beta(\anaid.\alpha\nt{id}) &=&
  (\of{\beta}{(\of{\AE}{C})(\anaid)})(\alpha\nt{id})
 \end{array}
 \]

\item[$\nt{Kind}(\t)$:]
 \[
 \begin{array}{rclcrcl}
 \nt{Kind}(\power{\t}) &=& \nt{power} &\quad&
 \nt{Kind}(\t_1\times\t_2) &=&\nt{product} \\
 \nt{Kind}(\t_1+\t_2) &=&\nt{sum} &&
 \nt{Kind}(\t_1\mapsto\t_2) &=&\nt{arrow}\\
 \nt{Kind}(\nt{int}) &=& \nt{integer} &&
 \nt{Kind}(\kindIt{\t}{\kappa}) &=& \kappa \\
 \end{array}
 \]

%\item[{$|\t|$}:]
% \H{타입 \t에 있는 태그들을 모두 없앤다. 예를들어,
%$|\t_1\times(\t_2+\t_3,1)|=\t_1\times(\t_2+\t_3).$}{}
\ei

%\bi
%\item \H{Rabbit과 nML에서 공통된 타입은 \tl{int}와 \tl{bool} 뿐이다.}
%        {Common types both in Rabbit and nML is only \tl{bool} and \tl{int}.}
%
%%\item[{$\varid$}:] \H{}{}
%\ei

\ruleclass{프로그램 분석 정의}{Analysis Definition}{\type{C}{\topdec}{C'}}
%\rule{\type{C}{\adec}{\coerce{\E}{\nt{Context}}}}
%     {\type{C}{\adec}{\E}}
\rule{\type{C}{\anadec}{\coerce{\AE}{\nt{Context}}}}
     {\type{C}{\anadec}{\AE}}
\rule{\type{C}{\sigdec}{\coerce{\GE}{\nt{Context}}}}
     {\type{C}{\sigdec}{\GE}}
\rule{\type{C}{\temdec}{\coerce{\TE}{\nt{Context}}}}
     {\type{C}{\temdec}{\TE}}
\rule{\type{C}{\topdec_1\;\topdec_2}{C_1+C_2}}
     {\type{C}{\topdec_1}{C_1}\quad
      \type{C+C_1}{\topdec_2}{C_2}}

\ruleclass{분석기 선언}{Analysis Declaration}{\type{C}{\anadec}{\AE}}
%\rule{\type{C}{\tl{analysis}\;\anabind}{NE}}
%     {\type{C}{\anabind}{NE}}
%\ruleclass{분석기 정의}{Analysis Binding}{\type{C}{\anabind}{NE}}
%\rule{\type{C}{\anaid\;\tl{=}\;\anaexp}{\{\entry{\anaid}{\E}\}}}
%     {\type{C}{\anaexp}{\E}}
\rule{\type{C}{\tl{analysis}\;\anaid\;\tl{=}\;\anaexp}
           {\{\entry{\anaid}{\E}\}}
     }
     {\type{C}{\anaexp}{\E}}

\ruleclass{분석기 정의식}{Aanalysis Expression}{\type{C}{\anaexp}{\E}}
\rule{\type{C}{\tl{ana}\;\adec\;\tl{end}}{\E}}
     {\type{C}{\adec}{\E}}
\rule{\type{C}{\temid\;\tl{(}\;\anaexp_1,\cdots,\anaexp_n\;\tl{)}}{\E}}
     {\deduce{\forall i.\type{C}{\anaexp_i}{\E_i}\quad
              \forall i.\sigmatch{\E_i}{\E_i'}	      
             }
      {\TE(\temid) = (((\anaid_1,\E_1'),\cdots,(\anaid_n,\E_n')),\E)}
     }

\ruleclass{분석기 타입 선언}{Analysis Signature Declaration}{\type{C}{\sigdec}{\GE}}
\rule{\type{C}{\tl{signature}\;\sigid\;\tl{=}\;\sigexp}
              {\{\entry{\sigid}{\E}\}}
     }
     {\type{C}{\sigexp}{\E}}

\ruleclass{분석기 타입식}{Signatre Expression}{\type{C}{\sigexp}{\E}}
\rule{\type{C}{\tl{sig}\;\adesc\;\tl{end}}{\E}}
     {\type{C}{\adesc}{\E}}
\rule{\type{C}{\sigid}{\E}}{\GE(\sigid) = \E}

\ruleclass{분석기 타입식 내용}{Signature Expression Content}{\type{C}{\adesc}{\E}}
\rule{\type{C}{\tl{set}\;\setdesc}{\E}}{\type{C}{\setdesc}{\E}}
\rule{\type{C}{\tl{lattice}\;\latdesc}{\E}}{\type{C}{\latdesc}{\E}}
\rule{\type{C}{\tl{val}\;\varid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\varid}{\tau}\}}{\nt{Env}}}}
     {\type{C}{\ty}{\tau}}
\rule{\type{C}{\tl{eqn}\;\varid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\varid}
			    {(\t_1',\t_2,(\St_1,\St_2))}
		    \}}{\nt{Env}}
	   }
     }
     {\type{C}{\ty}{\t_1\to\t_2}\quad
      \type{C}{\mbox{air'ed kinds}(\ty)}{(\St_1,\St_2)\quad
      \t_1' = \t_1\setminus\St_1\setminus\St_2}
     }
%\rule{\label{queryspec}
%      \type{C}{\tl{query}\;\ctlid\;\tl{:}\;\varlongid\nt{row}}{\E}
%     }
%     {\forall i.C_{\VE}(\varlongid_i)\in\nt{EqnType}
%     }
\rule{
      \type{C}{\tl{query}\;\ctlid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\ctlid}{\ty}\}}{\nt{Env}}}
     }
     {\type{C}{\ty}{\t\to\nt{bool}}}
\rule{\type{C}{\adesc_1\;\adesc_2}{\E_1+\E_2}}
     {\type{C}{\adesc_1}{\E_1}\quad\type{C+\E_1}{\adesc_2}{\E_2}}
%\note{\ref{queryspec}}
%     {\H{탐색의 타입은 탐색할 결과에 대한 분석 방정식
%         이름들을 열거해야 한다.}{}
%     }

\ruleclass{집합의 종류}{Set Kind Description}{\type{C}{\setdesc}{\E}}
\rule{\type{C}{\setid}{\coerce{\{\entry{\setid}{\cdot}\}}{\nt{Env}}}}
     {}
\rule{\label{setidkind}
      \type{C}{\kindIt{\setid}{\kind}}
           {\coerce{\{\entry{\setid}{\kind}\}}{\nt{Env}}}
     }{}
%     {\kind\not\in\{\tl{index},\tl{syntree}\}}
\rule{\type{C}{\setbind\mbox{\ as $\setdesc$}}{\E}}
     {\type{C}{\setbind}{\E}}

\ruleclass{래티스의 종류}{Lattice Kind Description}{\type{C}{\latdesc}{\E}}
\rule{\type{C}{\latid}{\coerce{\{\entry{\latid}{\cdot}\}}{\nt{Env}}}}
     {}
\rule{\type{C}{\kindIt{\latid}{\kind}}
           {\coerce{\{\entry{\latid}{\kind}\}}{\nt{Env}}}}
     {\kind\not=\{\tl{syntree},\tl{index},\tl{integer}\}}
\rule{\type{C}{\latbind\mbox{\ as $\latdesc$}}{\E}}
     {\type{C}{\latbind}{\E}}

\ruleclass{분석기와 분석기 타입 매치}{Analysis Type Match}{\sigmatch{\E}{\E'}}
\rule{\sigmatch{\E}{\E'}}
     {\sigmatch{\VE}{\VE'}\quad
      \sigmatch{\SE}{\SE'}\quad
      \sigmatch{\LE}{\LE'}\quad
      \sigmatch{\CV}{\CV'}\quad
      \sigmatch{\CN}{\CN'}
     }
\rule{\sigmatch{\VE}{\VE'}}
     {\forall\varid\in\dom{\VE'}.\VE(\varid) = \VE'(\varid)}
\rule{\label{sigmatchse} \sigmatch{\SE}{\SE'}}
     {\forall\setid\in\dom{\SE'}.\sigmatch{\SE(\setid)}{\SE'(\setid)}}
\rule{\sigmatch{\LE}{\LE'}}
     {\forall\latid\in\dom{\LE'}.\sigmatch{\LE(\latid)}{\LE'(\latid)}}
\rule{\sigmatch{\CV}{\CV'}}
     {\forall\cvarid\in\dom{\CV'}.\CV(\cvarid) = \CV'(\cvarid)}
\rule{\sigmatch{\CN}{\CN'}}
     {\forall\conid\in\dom{\CN'}.\CN(\conid) = \CN'(\conid)}
%\rule{\sigmatch{\nt{constraint}}{\nt{constraint}}}{}
\rule{\sigmatch{\t}{\t}}{}
\rule{\sigmatch{\t}{\cdot}}{}
\rule{\label{sigmatchkind} \sigmatch{\t}{\nt{Kind}(\t)}}{}
%\rule{\sigmatch{\Lt}{\Lt}}{}
%\rule{\sigmatch{\Lt}{\cdot}}{}
%\rule{\sigmatch{\Lt}{\nt{Kind}(\Lt)}}{}
\note{\ref{sigmatchse},\ref{sigmatchkind}}
     {\H{집합을 선언할 때는 그 종류가 \nt{index}나 \nt{syntree}라는
     것은 밝혀질 수 없으므로, 그러한 집합 종류와는 타입매치될 수 없다.
     어느 집합이 그러한 종류인지는 그 집합을 이용한 분석방정식이
     선언될 때 밝혀진다.}
     {Putting \nt{index} nor \nt{syntree} kind in a set description is
     a non-sense. Such kinds are known only when such sets are used
     with the kind annotations in the semantic function declarations.}
     }

\ruleclass{분석기 틀 선언}{Analysis Template Declaration}
	  {\type{C}{\temdec}{\TE}}
%\rule{\type{C}{\tl{analysis}\;
%\nt{tembind}}{\TE}}
%     {\type{C}{\nt{tembind}}{\TE}}
\rule{\deduce{\{\entry{\temid}
                 {(((\anaid_1,\E_1),(\anaid_2,\E_2)), \E)}
         \}}
      {
      \type{C}{\tl{analysis}\;\temid\;
               \tl{(}\;\anaid_1\;\tl{:}\;\sigexp_1\;\tl{,}\;
		       \anaid_2\;\tl{:}\;\sigexp_2\;
               \tl{)}\;
               \tl{=}\;\anaexp
	       }{}
      }
     }
     {\deduce{\type{C+\{\entry{\anaid_1}{\E_1},\entry{\anaid_2}{\E_2}\}}
                   {\anaexp}{\E}
             }
      {\type{C}{\sigexp_1}{\E_1}\quad
       \type{C}{\sigexp_2}{\E_2}\quad
      }
     }

\ruleclass{분석내용 선언}{Analysis Content Declaration}{\type{C}{\adec}{\E}}
\rule{\type{C}{\adec_1\;\adec_2}{\E_1+\E_2}}
     {\type{C}{\adec_1}{\E_1}\quad
      \type{C+\E_1}{\adec_2}{\E_2}}
\rule{\type{C}{\domdec\mbox{\ as $\adec$}}{\E}}
     {\type{C}{\domdec}{\E}}
\rule{\type{C}{\semdec\mbox{\ as $\adec$}}{\E}}
     {\type{C}{\semdec}{\E}}
\rule{\type{C}{\querydec\mbox{\ as $\adec$}}{\coerce{\VE}{\nt{Env}}}}
     {\type{\E}{\querydec}{\VE}}
%\rule{\notype{}{\domain\;\semantics\;\may{\query}}}
%     {\type{}{\domain}{\E}\quad
%      \type{\E}{\semantics}{\VE}\quad
%      \may{\type{\E+\VE}{\query}{\VE'}}
%     }

\ruleclass{도메인 선언}{Domain Declarations}{\type{C}{\domdec}{\E}}
\rule{\type{C}{\tl{set}\;\setbind}{\E}}
     {\type{C}{\setbind}{\E}}
\rule{\type{C}{\tl{lattice}\;\latbind}{\E}}
     {\type{C}{\latbind}{\E}}
\rule{\type{C}{\widenExp{\latid}{\match}}{\{\}}}
     {\t=\LE(\latid)\quad\type{\E}{\match}{\t\to\t}}
%\rule{\type{C}{\domain_1\;\domain_2}{\E_1+\E_2}}
%     {\type{C}{\domain_1}{\E_1}\quad\type{C+\E_1}{\domain_2}{\E_2}}
    
\ruleclass{집합의 정의}{Set Binding}{\type{C}{\setbind}{E}}
\rule{\label{setbind}
      \type{C}{\setid\;\tl{=}\;\setexp}
	   {(\VE,\{\entry{\setid}{\St}\},\LE,\CE)}
     }
     {\type{C}{\setexp}{\St,\VE}\quad
      \setid\not\in\dom{\SE}\cup\dom{\LE}} 
\rule{\label{cnstbind}
      \type{C}{\setid\;\tl{=}\;\setexp\;\tl{constraint}\;\cnstdec}
	   {(\VE,\{\entry{\setid}{\St}\},\LE,\CE)}}
     {\deduce{
       \type{C+\VE,\St}{\cnstdec}{\CE}\quad
       \setid\not\in\dom{\SE}\cup\dom{\LE}
      }{
       \type{C}{\setexp}{\St,\VE}\quad\nt{Kind}(\St)=\nt{power}
      }
     }
\note{\ref{setbind}}
     {\H{집합의 이름은 이미 정의된 집합이나 래티스의 이름이 아니어야한다.}
        {Set id must be fresh.}}
%\note{\ref{cnstbind}}
%     {\H{제약식들 뭉치로({\tt and}로 묶인) 선언될때 변수들이 재귀적으로 사용될
%수 있도록 $X$(선언되는 제약식 변수들의 집합)이 왼쪽에도
%있게된다.}{The set $X$ of constraint variables to be declared appear
%in the left-hand-side to support recursive bindings.}}

\ruleclass{래티스의 정의}{Lattice Binding}{\type{C}{\latbind}{\E}}
\rule{\label{latbind}
      \type{C}{\latid\;\tl{=}\;\latexp}{(\VE,\SE,\{\entry{\latid}{\Lt}\},\CE)}}
     {\type{C}{\latexp}{\Lt,\VE}\quad
      \latid\not\in\dom{\SE}\cup\dom{\LE}}
\note{\ref{latbind}}
     {\H{래티스의 이름은 이미 정의된 집합이나 래티스의 이름이 아니어야한다.}
        {Lattice id must be fresh.}}

\ruleclass{집합식}{Set Expression}{\type{C}{\setexp}{\St,\VE}}

\H{주의: $\St$는 집합의 속내용이다, 집합의 이름이 아니고.}
        {Note that $\St$ is a set structure, not a set name.}

\rule{\type{C}{\tl{/}\nt{tylongid}\tl{/}}{\nt{tylongid}_{\nt{nML}},\{\}}}
     {}
\rule{\type{C}{\setlongid}{\power{\St},\{\}}}
     {\St = C_{\SE}(\setlongid)}
\rule{\label{intervalset}
      \type{C}{\braceExp{\eO\;\tl{...}\;\eT}}{\intervalset,\{\}}}
     {\type{C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\label{elemtidrow}
      \type{C}{\braceExp{\elmtidrow}}{\{\elmtidrow\},\VE'}}
     {\deduce{
      \VE' = \{\entry{\elmtid}{\{\elmtidrow\}}\:|\:\elmtid\in\{\elmtidrow\}\}
      }{\{\elmtidrow\}\cap\dom{\VE}=\emptyset}
     }
\rule{\type{C}{\tl{power}\;\setexp}{\power{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
\rule{\type{C}{\setexp_1\;\tl{*}\;\setexp_2}{\St_1\times\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\setexp_1\;\tl{+}\;\setexp_2}{\St_1+\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\setexp_1\;\tl{->}\;\setexp_2}{\St_1\mapsto\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\parenIt{\setexp}}{\St,\VE}}
     {\type{C}{\setexp}{\St,\VE}}

\note{\ref{intervalset}}
     {\H{정수의 구간 부분집합도 정수로 한다.}
        {Integer set subsumes an integer interval.}}
\note{\ref{elemtidrow}}
     {\H{집합의 원소들로 쓰이는 이름들은 새로운 이름들이어야 한다.}
        {Set element identifiers must be fresh.}}

\ruleclass{제약식 집합}{Constraint Declaration}{\type{C,\St}{\cnstdec}{\CE}}
\rule{\label{cnstdec-a}
      \type{C,\St}
           {\tl{var = }\braceExp{\cvaridrow}\;\tl{index}\;\setexp\;\;
	    \tl{rhs = }\rhs}
           {(\CV',\CN)}
     }
     {\deduce{\dom{\CV}\cap\{\cvaridrow\}=\{\}\quad
	      \type{C+\CV',\St}{\rhs}{\CN}
      }
      {\type{C}{\setexp}{\St',\{\}}\quad
       \CV'\leteq\{\forall i.\entry{\cvarid_i}{(\St,\St')}\}
      }
     }
\rule{\label{cnstdec-b}
      \type{C,\St}
           {\tl{var = }\braceExp{\cvaridrow}\;\;
	    \tl{rhs = }\rhs}
           {(\CV',\CN)}
     }
     {\CV'\leteq\{\forall i.\entry{\cvarid_i}{\St}\}\quad
      \dom{\CV}\cap\{\cvaridrow\}=\{\}\quad
      \type{C+\CV',\St}{\rhs}{\CN}
     }
%\rule{\deduce{
%       (\{\entry{\cvarid}{\St}\},\CN)\;\may{+ \CE'},
%       \{\cvarid\}\;\may{\cup\; X'}
%      }{
%        \type{C,\St,X}
%             {\cvarid\;\tl{<-}\;\rhs \;\may{\tl{and}\;\cnstdec}}
%             {}
%      }
%     }
%     {\cvarid\in X\quad
%      \type{C,\St,X}{\rhs}{\CN}\quad
%      \may{\type{C,\St,X}{\cnstdec}{\CE',X'}}
%     }
\note{\ref{cnstdec-a},\ref{cnstdec-b}}
     {\H{제약식 변수들($\cvaridrow$)은 모두 달라야 한다.}{All
     constraint variables must be distinct.}}

\ruleclass{제약식의 오른팔 선언}{Constraint's RHS Declaration}
	  {\type{C,\St}{\rhs}{\CN}}
%\rule{\type{C,\St}
%	   {\tl{var}\;\may{\setid}\;\may{\tl{|}\;\rhs}}
%	   {\{\}}
%     }
%     {\may{\SE(\setid) = \St}}
\rule{\type{C,\St}
	   {\tl{var}\;\may{\setid}}
	   {\{\}}
     }
     {\may{\SE(\setid) = \St}}
%\rule{\label{rhsa}
%      \type{C,\St}
%           {\conid\;\may{\tl{:}\;\tl{atomic}}\;\may{\tl{|}\;\rhs}}
%           {\{\entry{\conid}{\St}\}\;\may{+ \CN}}
%     }
%     {\conid\not\in\dom{\CN}\quad\may{\type{C,\St}{\rhs}{\CN}}}
%\rule{\label{rhsb}
%      \type{C,\St}
%           {\conid\;\carg\;\may{\tl{:}\;\tl{atomic}}\;\may{\tl{|}\;\rhs}}
%           {\{\entry{\conid}{\t_1\to\St}\}\;\may{+ \CN}}
%     }
%     {\conid\not\in\dom{\CN}\quad
%      \type{C,\St}{\carg}{\t_1}\quad
%      \may{\type{C,\St}{\rhs}{\CN}}
%     }
\rule{\label{rhsa}
      \type{C,\St}
           {\conid\;\may{\tl{:}\;\tl{atomic}}}
           {\{\entry{\conid}{\St}\}}
     }
     {}
\rule{\label{rhsb}
      \type{C,\St}
           {\conid\;\carg\;\may{\tl{:}\;\tl{atomic}}}
           {\{\entry{\conid}{\t_1\to\St}\}}
     }
     {
      \type{C,\St}{\carg}{\t_1}
     }
\rule{\label{rhsrow}
      \type{C,\St}
           {\rhs_1\;\tl{|}\;\rhs_2}
           {\CN_1+\CN_2}
     }
     {\type{C,\St}{\rhs_1}{\CN_1}\quad
      \type{C,\St}{\rhs_2}{\CN_2}\quad
      \dom{\CN_1}\cap\dom{\CN_2}=\emptyset
     }
%\rule{\notype{C,\St}{\tl{var}}}{}
%\rule{\notype{C,\St}{\tl{var}\;\setid}}
%     {\SE(\setid) = \St}

\note{\ref{rhsrow}}
     {\H{제약식에 사용되는 함수심볼들은 모두 달라야 한다.}
        {Function symbols in constraint's rhs declarations must all be
	  distinct.}
     }

\ruleclass{제약식 함수심볼의 변수들}{}{\type{C,\St}{\carg}{\t}}
\rule{\type{C,\St}{\tl{var}}{\St}}{}
\rule{\type{C,\St}{\tl{var}\;\setlongid}{\St'}}
     {\SE(\setlongid) = \St'}
\rule{\label{setexpincnstdec}
      \type{C,\St}{\setexp}{\St'}}
     {\type{C}{\setexp}{\St',\{\}}}
\rule{\label{setexpincnstdec2}
      \type{C,\St}{\tl{(}\;\carg_1\tl{,}\;\carg_2\;\tl{)}}
           {\St_1\times\St_2}
     }
     {\type{C,\St}{\carg_1}{\St_1}\quad\type{C}{\carg_2}{\St_2}}

\note{\ref{setexpincnstdec}}
     {\H{제약식 함수심볼의 선언에 쓰는 집합식은 새로운 환경($\VE$)을
      만들어내지 않아야 한다. (for convenience, not must)}
     {For convenience, no non-empty $\VE$ is constructed from the set
     expressions used in declaring function symbol's argument types.}
     }

%\ruleclass{제약식 변수}{Constraint Variable}{\notype{C,X}{\cvar}}
%\rule{\notype{C,X}{\cvarid\;\may{\tl{index}\;\setexp}}}
%     {\cvarid\in X\quad
%      \may{\setexp\mbox{\ is not a compound set}\quad
%	   \type{C}{\setexp}{s}\quad
%           \CE(\cvarid) = s
%          }
%     }
%\rule{\notype{C,X}{\indexExp{\cvarid}{e}}}
%     {\CE(\cvarid) = (\setid, s)\quad
%      \type{C}{e}{s}}

\ruleclass{래티스 식}{Lattice Expression}{\type{C}{\latexp}{\Lt,\VE}}

\H{주의: $\Lt$는 래티스의 속내용이다, 래티스의 이름이 아니고.}
        {Note that $\Lt$ is a lattice structure, not a lattice name.}

\rule{\type{C}{\tl{/}\nt{strlongid}\tl{/}}{\nt{strlongid}_{\nt{nML}},\{\}}}
     {}
\rule{\type{C}{\latid}{\Lt,\{\}}}
     {\Lt = C_{\LE}(\latlongid)}
\rule{\type{C}{\tl{flat}\;\setexp}{\flat{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
\rule{\type{C}{\tl{power}\;\setexp}{\power{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
\rule{\label{orderedset}
      \type{C}{\setexp\;\tl{order}\;\order}{\ordered{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}\quad
      \type{C}{\order}{\St}\quad
      \nt{Lattice}(\order)}
\rule{\type{C}{\latexp_1\;\tl{*}\;\latexp_2}{\Lt_1\times\Lt_2,\VE_1+\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\latexp_1\;\tl{+}\;\latexp_2}{\Lt_1+\Lt_2,\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\latexp_1\;\tl{->}\;\latexp_2}{\Lt_1\mapsto\Lt_2,\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\setexp\;\tl{->}\;\latexp}{\St\mapsto\Lt,\VE_2}}
     {\type{C}{\setexp}{\St,\VE_1}\quad
      \type{C+\VE_1}{\latexp}{\Lt,\VE_2}}
\rule{\type{C}{\parenIt{\latexp}}{\Lt,\VE}}
     {\type{C}{\latexp}{\Lt,\VE}}

\note{\ref{orderedset}}
     {\H{$\nt{Lattice}(\order)$는 집합 원소들 사이의 순서($\order$)가
         래티스 조건을 만족하는 지 확인한다.}
        {$\nt{Lattice}(\order)$ checks if the $\order$ satisfies the
         condition for being a lattice.}
     }

\ruleclass{래티스 원소들의 순서}{Partial Order}{\type{C}{\order}{\St}}
\rule{\type{C}{\po\;\pat}{\St}}
     {\type{C}{\pat}{\VE,\St\times\cdots\times\St}}
\rule{\type{C}{\order_1\:\tl{|}\:\order_2}{\St}}
     {\type{C}{\order_i}{\St,\VE}\quad i=1,2}

\ruleclass{분석 식}{Analysis Expression}{\type{C}{\e}{\t}}
\rule{\type{\C}{\tl{/}\m{\nt{ne}}\tl{/}}{\nt{ty}_{\nt{nML}}}}
     {}
\rule{\label{uid-exp}
      \type{\C}{\setlongid}{\St}}
     {\St=C_{\SE}(\setlongid)}
\rule{\label{lid-exp}\type{\C}{\varlongid}{\St}}
     {\St=C_{\VE}(\varlongid)} 
\rule{\type{\C}{\cvarlongid\;\tl{@}\;\pat\;\tl{<-}\;\rhsexp}{\St}}
     {
       \CV(\cvarlongid) = (\St,\St')\quad
       \type{\C,\St}{\rhsexp}{\char`\_}\quad
       \type{\C}{\pat}{\char`\_,\St'}
     }
\rule{\type{\C}{\cvarlongid\;\tl{<-}\;\rhsexp}{\St}}
     {
       \CV(\cvarlongid) = \St\quad
       \type{\C,\St}{\rhsexp}{\char`\_}
     }
\rule{\type{\C}{\integer}{\nt{int}}}
     {}
\rule{\type{\C}{(\tl{top}|\tl{bottom}|\tl{\char`\^}|\tl{\char`\_\char`\_})}{\Lt}}
     {}
%\rule{\type{\C}{\varid}{\t}}
%     {\t=\VE(\varid)}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*}|\tl{-})\;\eT}{\nt{int}}}
     {\type{\C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*})\;\eT}{\Lt}}
     {\type{\C}{\e_i}{\Lt}\quad i=1,2}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*}|\tl{-})\;\eT}{\power{\t}}}
     {\type{\C}{\e_i}{\power{\t}}\quad i=1,2}
\rule{\type{\C}{\eO\;\rop\;\eT}{\nt{bool}}}
     {\type{\C}{\e_i}{\t}\quad i=1,2\qquad\ropTy{\t}}

\rule{\type{\C}{\braceExp{\eO\;\tl{...}\;\eT}}{\power{\nt{int}}}}
     {\type{\C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\label{collection-exp}
      \type{\C}{\braceExp{\erow}}{\power{\t}}}
     {\forall\e\in\{\erow\}.\type{\C}{\e}{\t}}
\rule{\type{\C}{\setcomExp{\erow}{\qual}}{\power{\t}}}
     {\type{\C}{\qual}{\VE}\quad
      \forall\e\in\{\erow\}.\type{\C+\VE}{\e}{\t}}
\rule{\label{mrule-collection-exp}
      \type{\C}{\braceExp{\mrulerow}}{\t_1\mapsto\t_2}}
     {\forall\mrule\in\{\mrulerow\}.\type{\C}{\mrule}{\t_1\to\t_2}\quad
      \t_1\mapsto\t_2\in\nt{Set}\cup\nt{Lattice}}
\rule{\label{mrule-qual-collection-exp}
      \type{\C}{\setcomExp{\mrulerow}{\qual}}{\t_1\mapsto\t_2}}
     {\deduce{
       \forall\mrule\in\{\mrulerow\}.\type{\C+\VE}{\mrule}{\t_1\to\t_2}
      }{\type{\C}{\qual}{\VE}\quad
        \t_1\mapsto\t_2\in\nt{Set}\cup\nt{Lattice}
      }
     }
\rule{\type{\C}{\foldExp{(\tl{+}|\tl{*})}{\e}}{\Lt/\power{\t}}}
     {\type{\C}{\e}{\power{\Lt}/\power{\power{\t}}}}
\rule{\type{\C}{\tupleExp{\e_1}{\e_2}}{\t_1\times\t_2}}
     {\type{\C}{\e_i}{\t_i}\quad i=1,2}
\rule{\type{\C}{\projExp{\e}{\tl{1}}}{\t_1}}
     {\type{\C}{\e}{\t_1\times\t_2}}
\rule{\type{\C}{\projExp{\e}{\tl{2}}}{\t_2}}
     {\type{\C}{\e}{\t_1\times\t_2}}
\rule{\type{\C}{\injExp{\e}{\ty}{\tl{1}}}{\t_1+\t_2}}
     {\type{\C}{\e}{\t_1}\quad
      \type{\C}{\ty}{\t_1+\t_2}}
\rule{\type{\C}{\injExp{\e}{\ty}{\tl{2}}}{\t_1+\t_2}}
     {\type{\C}{\e}{\t_2}\quad
      \type{\C}{\ty}{\t_1+\t_2}}
\rule{\type{\C}{\letExp{\valdec}{\e}}{\t}}
     {\type{\C}{\valdec}{\VE}\quad
      \type{\C+\VE}{\e}{\t}}
\rule{\type{\C}{\fnExp{\match}}{\t_1\to\t_2}}
     {\type{\C}{\match}{\t_1\to\t_2}}
\rule{\type{\C}{\appExp{\eO}{\eT}}{\t_2}}
     {\type{\C}{\eO}{\t_1\to\t_2\;\mbox{or}\;\t_1\mapsto\t_2}\quad
      \type{\C}{\eT}{\t_1}}
\rule{\type{\C}{\parenExp{\e}}{\t}}
     {\type{\C}{\e}{\t}}
\rule{\type{\C}{\coerceExp{\e}{\ty}}{\t}}
     {\type{\C}{\e}{\t}\quad\type{\C}{\ty}{\t}}
\rule{\type{\C}{\indexExp{\may{\tl{pre}}\;\varlongid}{e}}{\t_1}} 
     {C_{\VE}(\varlongid) = (\t_1,\t_2,(s_1,s_2))\quad
      \type{C}{e}{s_2}}
\rule{\type{\C}{\indexExp{\may{\tl{post}}\;\varlongid}{e}}{\t_2}}
     {C_{\VE}(\varlongid) = (\t_1,\t_2,(s_1,s_2))\quad
      \type{C}{e}{s_2}}

%\rule{\type{\E}{\e}{\t'}}
%     {\type{\E}{\e}{\t}\quad\cast{\E}{\t}{\t'}}
%
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\nt{int}}}
%     {\type{\E}{\e}{\t}\quad\SE(\domid)=\intervalset}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1}}
%     {\type{\E}{\e}{\St_1+\St_2}\quad\SE(\domid)=\St_1}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1+\St_2}}
%     {\type{\E}{\e}{\St_1}\quad\SE(\domid)=\St_1+\St_2}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\flat{\St}}}
%     {\type{\E}{\e}{\St}\quad\SE(\domid)=\flat{\St}}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1}}
%     {\type{\E}{\e}{\St_1+\St_2}\quad\SE(\domid)=\St_1}

\note{\ref{uid-exp}}
     {\H{분석식에서 \uid는 정의된 집합의 이름이어야 한다.}{\uid\ in
     semantic expression must be a set id.}}
\note{\ref{lid-exp}}
     {\H{분석식에서 \lid는 집합의 원소이름(\elmtid)이거나 정의된
     변수(\varid) 이름이어야 한다.} 
        {\lid\ in semantic expression must be either a set element id or a variable id.}}
\note{\ref{collection-exp}}
     {\H{집합의 원소나 래티스의 원소를 모아놓을 수 있다.}{Collections
     of set elements or lattice elements.}}
\note{\ref{mrule-collection-exp},\ref{mrule-qual-collection-exp}}
     {\H{함수는 집합이나 래티스로 정의될 수 있는
         것만 가능하다 ($\t_1\mapsto\t_2\in\nt{Set}\cup\nt{Lattice}$).
         예를들어, 래티스 원소를 집합의 원소로 보내는 함수는 만들 수 없다.}
        {A map is legal only when it is an element of a
     Rabbit-definiable set or lattice.}}

\ruleclass{관계연산 가능한 타입}{Type with Relational Operations}{\ropTy{\t}}
%\rule{\ropTy{\nt{int}}}{}
%\rule{\ropTy{\nt{bool}}{}
%\rule{\ropTy{\t}}{\t\;\mbox{as}\;\Lt\quad\ropTy{\Lt}}
%\rule{\ropTy{\t}}{\t\;\mbox{as}\;\St\quad\ropTy{\St}}
%\rule{\ropTy{\t_1\times\t_2}}{\ropTy{\t_1}\quad\ropTy{\t_2}}
%\rule{\ropTy{\t_1+\t_2}}{\ropTy{\t_1}\quad\ropTy{\t_2}}
%\rule{\ropTy{\power{\t}}}{\ropTy{\t}}
%\rule{\ropTy{\kindIt{\t}{\kappa}}}{\ropTy{\t}}
\rule{\ropTy{\t}}
     {\mbox{$\t$ has neither $\t_1\to\t_2$ nor nML type as its component.}}
%\rule{\ropTy{\St}}{\mbox{$\St$ has no nML type as its component}}
%\rule{\ropTy{\Lt}}{\mbox{$\Lt$ has no nML type as its component}}

\ruleclass{타입 식}{Type Expression}{\type{C}{\ty}{\t}}
\rule{\type{C}{\tl{int}}{\nt{int}}}
     {}
\rule{\type{C}{\tl{/}\tylongid\tl{/}}{\tylongid_{\nt{nML}}}}
     {}
\rule{\type{C}{\domlongid}{\t}}
     {\t = (\SE+\LE)(\domlongid)}
\rule{\type{C}{\tl{power}\;\ty}{\power{\t}}}
     {\type{C}{\ty}{\t}}
\rule{\label{fnty}
      \type{C}{\ty_1\;\tl{->}\;\ty_2}{\t_1\to\t_2}}
     {\type{C}{\ty_i}{\t_i}\quad i=1,2}
\rule{\type{C}{\ty_1\;\tl{*}\;\ty_2}{\t_1\times\t_2}}
     {\type{C}{\ty_i}{\t_i}\quad i=1,2}
\rule{%\label{sumtypemustbedefined}
      \type{C}{\ty_1\;\tl{+}\;\ty_2}{\t_1+\t_2}}
     {\type{C}{\ty_i}{\t_i}\quad i=1,2
%      \quad\t_1+\t_2\in\ran{\SE}\cup\ran{\LE}
     }
\rule{\type{C}{\parenIt{\ty}}{\t}}
     {\type{C}{\ty}{\t}}
\rule{\type{C}{\kindIt{\ty}{\kind}}{\kindIt{\t}{\kind}}}
     {\type{C}{\ty}{\t}}
\rule{\type{C}{\kindIt{\ty}{\tl{index}}}{\kindIt{\St}{\nt{index}}}}
     {\type{C}{\ty}{\St}\quad
      \mbox{air $\kindIt{\St}{\nt{index}}$}}
\rule{\type{C}{\kindIt{\ty}{\tl{syntree}}}{\kindIt{\St}{\nt{syntree}}}}
     {\type{C}{\ty}{\St}\quad
      \mbox{air $\kindIt{\St}{\nt{syntree}}$}}
\note{\ref{fnty}}
     {\H{함수 타입식은 함수집합/래티스($\t_1\mapsto\t_2$)가 아니고
         함수 계산식의 타입($\t_1\to\t_2$)을 이른다.}
	{Function type denotes semantic functions, not the function
         lattices or sets.} 
     }
%\note{\ref{sumtypemustbedefined}}
%     {\H{합 타입은 집합이나 래티스로 정의되어 있어야 한다. (번역의
%         편리를 위해서.)}
%        {Sum type should be defined as a domain (set or
%         lattice).}
%     }

\ruleclass{바람에 실려온 힌트}{Aired Kind Hints}
	  {\type{C}{\mbox{air'ed kinds}(\star)}{(\St_1,\St_2)}}

\mbox{$\star$ is either \e\ or\ \ty.}
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\St_1,\St_2)}}
     {\kindIt{\St_1}{\nt{syntree}}\;\;
      \kindIt{\St_2}{\nt{index}}
      \mbox{\ are air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\St,\St)}}
     {\mbox{only\ }\kindIt{\St}{\nt{syntree}}
      \mbox{\ is air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\cdot,\St)}}
     {\mbox{only\ }\kindIt{\St}{\nt{index}}
      \mbox{\ is air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\cdot,\cdot)}}
     {\mbox{nothing is air'ed from $\star$}
     }

%\rule{\type{\E}{\parenExp{\ty\;\tl{,}\;\tl{1}}}{(\t,1)}}
%     {\type{\E}{\ty}{\t}}
%\rule{\type{\E}{\parenExp{\ty\;\tl{,}\;\tl{2}}}{(\t,2)}}
%     {\type{\E}{\ty}{\t}}
%
%\ruleclass{타입 적응}{Type Cast}{\cast{\E}{\t}{\t'}}
%\rule{\cast{\E}{\t}{\t}}{}
%\rule{\label{cast-into-sum}
%      \cast{\E}{\t_{1/2}}{(\t_1+\t_2,{1/2})}}
%     {\exists 1\:\domid:\t_1+\t_2 = (\SE+\LE)(\domid)}
%\rule{\cast{\E}{(\t_1+\t_2,1/2)}{\t_{1/2}}}{}
%\rule{\label{cast-into-clean}
%      \cast{\E}{(\t_1+\t_2,1/2)}{\t_1+\t_2}}{}
%
%\note{\ref{cast-into-sum}}
%     {\H{타입($\t_i$)이 덧셈타입($\t_1+\t_2$)으로 적응할 수 있으려면 그 
%       타입($\t_1+\t_2$)은 집합이나 래티스로 사용자가 선언해 놓은
%       것이어야 한다. 이때, 그러한 집합이나 래티스로 정의된 이름은
%       유일해야 한다.}{}}
%\note{\ref{cast-into-clean}}
%     {\H{태그가 붙은 덧셈타입$(\t_1+\t_2, t)$은 태그가 없는 
%         타입($\t_1+\t_2$)으로 적응할 수 있다.}{}}
%
\ruleclass{패턴 매치}{Pattern Match}{\type{C}{\match}{\t_1\to\t_2}}
\rule{\type{C}{\mrule\;\may{\tl{|}\;\match}}{\t_1\to\t_2}}
     {\type{C}{\mrule}{\t_1\to\t_2}\quad
      \may{\type{C}{\match}{\t_1\to\t_2}}}

\ruleclass{매치 룰}{Match Rule}{\type{C}{\mrule}{\t_1\to\t_2}}
\rule{\type{C}{\pat\;\tl{=>}\;e}{\t_1\to\t_2}}
     {\type{C}{\pat}{\VE,\t_1}\quad\type{C+\VE}{e}{\t_2}}

\ruleclass{패턴}{Pattern}{\type{C}{\pat}{\VE,\t}}
\rule{\type{C}{\tl{/}\nt{npat}\tl{/}}{\VE,\tylongid_{\nt{nML}}}}
     {}
\rule{\type{C}{\tl{\char`\_}}{\{\},\t}}{}
\rule{\type{C}{\varid}{\{\entry{\varid}{\t}\},\t}}{}
\rule{\type{C}{\braceExp{\patrow\;\may{\tl{...}}}}{\VE,\power{\t}}}
     {\type{C}{\patrow}{\VE,\t}}
\rule{\type{C}{\braceExp{\pat_1\;\tl{...}\;\pat_2}}
           {\VE_1+\VE_2,\power{\nt{int}}}}
     {\type{C}{\pat_1}{\VE_1,\nt{int}}\quad
      \type{C}{\pat_2}{\VE_2,\nt{int}}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}
\rule{\type{C}{\braceExp{\mpatrow\;\may{\tl{...}}}}{\VE,\t_1\mapsto\t_2}}
     {\type{C}{\mpatrow}{\VE,\t_1\mapsto\t_2}}
\rule{\type{C}{\injExp{\pat}{\ty}{\tl{1}}}{\VE,\t_1+\t_2}}
     {\type{C}{\pat}{\VE,\t_1}\quad
      \type{C}{\ty}{\t_1+\t_2}}
\rule{\type{C}{\injExp{\pat}{\ty}{\tl{2}}}{\VE,\t_1+\t_2}}
     {\type{C}{\pat}{\VE,\t_2}\quad
      \type{C}{\ty}{\t_1+\t_2}}
\rule{\type{C}{\tupleExp{\pat_1}{\pat_2}}{\VE_1+\VE_2,\t_1\times\t_2}}
     {\type{C}{\pat_1}{\VE_1,\t_1}\quad\type{C}{\pat_2}{\VE_2,\t_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}
\rule{\type{C}{\guardPat{\pat}{\guard}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}\quad\notype{C+\VE}{\guard}}
\rule{\type{C}{\orPat{\pat_1}{\pat_2}}{\VE,\t}}
     {\type{C}{\pat_1}{\VE,\t}\quad\type{C}{\pat_2}{\VE,\t}}
\rule{\type{C}{\asPat{\varid}{\pat}}{\VE+\{\varid\mapsto\t\},\t}}
     {\type{C}{\pat}{\VE,\t}}
\rule{\type{C}{\coerceExp{\pat}{\ty}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}\quad\type{C}{\ty}{\t}}
\rule{\type{C}{\parenIt{\pat}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}}
%\rule{\type{\E}{\pat}{\VE,\t'}}
%     {\type{\E}{\pat}{\VE,\t}\quad\cast{\E}{\t}{\t'}}

\ruleclass{패턴들}{Patttern Row}{\type{C}{\patrow}{\VE,\t}}
\rule{\type{C}{\pat\;\tl{,}\;\patrow}{\VE+\VE',\t}}
     {\type{C}{\pat}{\VE,\t}\quad
      \type{C}{\patrow}{\VE',\t}\quad
      \dom{\VE}\cap\dom{\VE'}=\emptyset}

\ruleclass{함수 패턴}{Match-Rule Pattern}{\type{C}{\mpat}{\VE,\t}}
\rule{\type{C}{\pat_1\;\tl{=>}\;\pat_2}{\VE_1+\VE_2,\t_1\mapsto\t_2}}
     {\type{C}{\pat_1}{\VE_1,\t_1}\quad
      \type{C}{\pat_2}{\VE_2,\t_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}

\ruleclass{함수 패턴들}{Match-Rule Pattern Row}{\type{C}{\mpatrow}{\VE,\t}}
\rule{\type{C}{\mpat\;\tl{,}\;\mpatrow}{\VE+\VE',\t}}
     {\type{C}{\mpat}{\VE,\t}\quad
      \type{C}{\mpatrow}{\VE',\t}\quad
      \dom{\VE}\cap\dom{\VE'}=\emptyset}

\ruleclass{집합 원소의 자격}{Qualification}{\type{C}{\qual}{\VE}}
\rule{\type{C}{\gen\may{\;\tl{,}\;\guard}}{\VE}}
     {\type{C}{\gen}{\VE}\quad\may{\notype{C+\VE}{\guard}}}

\ruleclass{집합 원소의 소속}{Generation}{\type{C}{\gen}{\VE}}
\rule{\type{C}{\pat\;\tl{from}\;\e}{\VE}}
     {\type{C}{\pat}{\VE,\t}\quad\type{C}{\e}{\power{\t}}}
\rule{\type{C}{\mpat\;\tl{from}\;\e}{\VE}}
     {\type{C}{\mpat}{\VE,\t_1\mapsto\t_2}\quad
      \type{C}{\e}{\t_1\mapsto\t_2}}
\rule{\type{C}{\gen_1\;\tl{,}\;\gen_2}{\VE_1+\VE_2}}
     {\type{C}{\gen_1}{\VE_1}\quad
      \type{C}{\gen_2}{\VE_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}

\ruleclass{집합 원소의 제한}{Guard}{\notype{C}{\guard}}
\rule{\label{firstorder}
      \notype{C}{\eO\;\rop\;\eT}}
     {\type{C}{\e_i}{\t}\quad i=1,2\quad\ropTy{\t}}
\rule{\notype{C}{\eO\;\tl{in}\;\eT}}
     {\type{C}{\eO}{\t}\quad\type{C}{\eT}{\power{\t}}}
\rule{\notype{C}{\tl{not}\;\guard}}
     {\notype{C}{\guard}}
\rule{\notype{C}{\guard_1\;(\tl{and}|\tl{or})\;\guard_2}}
     {\notype{C}{\guard_1}\quad\notype{C}{\guard_2}}
\rule{\notype{C}{\forallGuard{\gen}{\guard}}}
     {\type{C}{\gen}{\VE}\quad\notype{C+\VE}{\guard}}
\rule{\notype{C}{\forsomeGuard{\gen}{\guard}}}
     {\type{C}{\gen}{\VE}\quad\notype{C+\VE}{\guard}}
\rule{\notype{C}{\parenIt{\guard}}}
     {\notype{C}{\guard}}
\note{\ref{firstorder}}
     {\H{$\ropTy{\t}$는 타입 $\t$가 계산함수타입
         (함수집합/함수래티스가 아닌)을 포함하고 있지 않고, nML 타입이
         아니어야한다.}
        {}
}

\ruleclass{분석기 선언}{Semantics Declarations}{\type{\C}{\semdec}{\E}}
\rule{\type{C}{\valdec}{\coerce{\VE}{\nt{Env}}}}
     {\type{C}{\valdec}{\VE}}
\rule{\type{C}{\eqndec}{\coerce{\VE}{\nt{Env}}}}
     {\type{C}{\eqndec}{\VE}}
\rule{\type{C}{\ccrdec}{\{\}}}
     {\notype{C}{\ccrdec}}
%      \may{\type{\E}{\semantics}{\VE'}}}
%%      \dom{\VE}\cap\dom{\VE'}=\emptyset}}

\ruleclass{분석값 선언}{Auxiliary Value Declaration}{\type{\C}{\valdec}{\VE}}
\rule{\type{\C}{\tl{val}\;\vbind}{\VE}}
     {\type{\C}{\vbind}{\VE}}
\rule{\type{\C}{\tl{val rec}\;\vbind}{\VE}}
     {\type{\C+\VE}{\vbind}{\VE}}

\ruleclass{분석값 정의}{Auxiliary Value Binding}{\type{\C}{\vbind}{\VE}}
\rule{\type{\C}{\pat\;\tl{=}\;\e\;\may{\tl{and}\;\vbind}}{\VE\;\may{+\VE'}}}
     {\type{\C}{\pat}{\VE,\t}\quad
      \type{\C}{\e}{\t}\quad
      \may{\type{\C}{\vbind}{\VE'}\quad\dom{\VE}\cap\dom{\VE'}=\emptyset}
     }

\ruleclass{분석 방정식 선언}{Semantic Equation Declaration}
          {\type{\C}{\eqndec}{\VE}}
\rule{\type{\C}{\tl{eqn}\;\ebind}{\VE}}
     {\type{\C}{\ebind}{\VE}}
\rule{\type{\C+\VE}{\tl{eqn rec}\;\ebind}{\VE}}
     {\type{\C}{\ebind}{\VE}}

\ruleclass{분석 방정식 정의}{Semantic Equation Binding}{\type{\C}{\ebind}{\VE}}
\rule{\type{\C}{\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind}}
	   {\{\entry{\varid}{\t}\}\;\may{+\VE}}
     }
     {\type{\C}{\e}{\t}\quad
      \may{\type{C}{\ebind}{\VE}\quad
           \varid\not\in\dom{\VE}}
     }
\rule{\type{\C}{\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind}}
           {\{\entry{\varid}{(\t_1',\t_2,(\St_1,\St_2))}\}\;\may{+\VE}}
     }
     {\deduce{
       \t_1'=\t_1\setminus\St_1\setminus\St_2\quad
       \may{\type{\C}{\ebind}{\VE}\quad
            \varid\not\in\dom{\VE}}
      }{
       \type{\C}{\e}{\t_1\to\t_2}\quad
       \type{\C}{\mbox{air'ed kinds}(\e)}{(\St_1,\St_2)}\quad 
       \St_1\in\t_1\quad\St_2\in\t_1
      }
     }

%\rule{\type{\E}{\nt{syntreekind}\;\nt{indexkind}}{(\St_1,\St_2)}}
%     {\SE(\setid_i)=\St_i\quad i=1,2}
%\rule{\type{\E}{\parenIt{\kind}}{(\St_1,\St_2)}}
%     {\type{\E}{\kind}{(\St_1,\St_2)}}

\ruleclass{제약식 푸는 규칙}{Constraint Closure Rules}{\notype{\C}{\ccrdec}}
\rule{\notype{\C}{\tl{ccr}\;\ccrbind}}
     {\notype{\C}{\ccrbind}}
\ruleclass{제약식 푸는 규칙 정의}{Constraint Closure Rule Binding}{\notype{\C}{\ccrbind}}
\rule{\notype{\C}{\tl{ccr}\;\cnstguard\;\tl{--}^+\;\constraintrow\;\may{\tl{|}\;\ccrbind}}}
     {\type{\C}{\cnstguard}{\VE}\quad
      \forall i.\type{\C}{\constraint_i}{\char`\_}\quad
      \may{\notype{\C}{\ccrbind}}
     }
%     {\forall i.\notype{\C}{\constraint_{1i}}\quad
%      \forall i.\notype{\C}{\constraint_{2i}}
%     }
\ruleclass{제약식 또는 조건}{Constraint or Guard Sequence}
          {\type{C}{\cnstguard}{\VE}}
\rule{\type{C}{\constraint\mbox{\ as \cnstguard}}{\VE}}
     {\type{C}{\constraint}{\VE}}
\rule{\type{C}{\guard\mbox{\ as \cnstguard}}{\{\}}}
     {\notype{C}{\guard}}
\rule{\type{C}{\cnstguard_1\;\tl{,}\;\cnstguard_2}{\VE_1+\VE_2}}
     {\type{C}{\cnstguard_1}{\VE_1}\quad
      \type{C+\VE_1}{\cnstguard_2}{\VE_2}
     }

\ruleclass{제약식 하나}{Constraint}{\type{\C}{\constraint}{\VE}}
\rule{\type{\C}{\cvarlongid\;\tl{@}\;\pat\;\tl{<-}\;\rhsexp}{\VE}}
     {\CV(\cvarlongid) = (\St,\St')\quad
      \type{\C,\St}{\rhsexp}{\VE}\quad
      \type{\C}{\pat}{\char`\_,\St'}
     }
\rule{\type{\C}{\cvarlongid\;\tl{<-}\;\rhsexp}{\VE}}
     {\CV(\cvarlongid) = \St\quad
      \type{\C,\St}{\rhsexp}{\VE}
     }

\ruleclass{제약식의 오른팔식}{Constraint's RHS Expression}
          {\type{\C,\St}{\rhsexp}{\VE}}
\rule{\type{\C,\St}{\cvarlongid}{\{\}}}
     {\CV(\cvarlongid) = \St}
\rule{\type{\C,\St}{\cvarlongid\;\tl{@}\;\pat}{\VE}}
     {\CV(\cvarlongid) = (\St,\St')\quad
      \type{\C}{\pat}{\VE,\St'}
     }
\rule{\type{\C,\St}{\conlongid}{\{\}}}
     {\CN(\conlongid) = \St}
\rule{\type{\C,\St}{\conlongid\;\cargexp}{\VE}}
     {\CN(\conlongid) = \t\to\St\quad
      \type{\C,\t}{\cargexp}{\VE}}

\ruleclass{제약식 함수심볼의 인자식}{Constraint's RHS Arguments}
          {\type{\C,\t}{\cargexp}{\VE}}
\rule{\type{\C,\t}{\cvarlongid\;\may{\tl{@}\;\pat}}{\{\}}}
     {\CV(\cvarlongid) = (\t,\St)\quad
      \may{\type{\C}{\pat}{\char`\_,\St}}
     }
\rule{\type{\C,\t}{\pat}{\VE}}
     {\type{\C}{\pat}{\VE,\t}}
\rule{\type{\C,\t}{\tl{(}\;\cargexp\;\tl{)}}{\VE}}
     {\type{\C,\t}{\cargexp}{\VE}}
\rule{\type{\C,\t_1\times\t_2}{\tl{(}\;\cargexp_1\tl{,}\;\cargexp_2\;\tl{)}}
           {\VE+\VE'}}
     {\type{\C,\t_1}{\cargexp_1}{\VE}\quad
      \type{\C,\t_2}{\cargexp_2}{\VE'}}

\ruleclass{제약식 함수심볼의 이미지}{Constraint RHS's Image}
          {\notype{\C}{\cimdec}}
\rule{\notype{\C}{\tl{cim}\;\cimbind}}
     {\notype{\C}{\cimbind}}

\ruleclass{제약식 함수심볼의 이미지 정의}{Constraint RHS's Image Binding}
          {\notype{\C}{\cimbind}}
\rule{\notype{\C}{\conlongid\;\pat\;\tl{=}\;\e\;\may{\tl{|}\;\notype{\C}{\cimbind}}}}
     {\CN(\conlongid) = \t\to\St\quad
      \type{\C}{\pat}{\VE,\t}\quad
      \type{\C+\VE}{\e}{\St}\quad
      \may{\notype{\C}{\cimbind}}}
\rule{\notype{\C}{\tl{cim}\;\conlongid\;\tl{=}\;\e\;\may{\tl{|}\;\notype{\C}{\cimbind}}}}
     {\CN(\conlongid) = \St\quad
      \type{\C+\VE}{\e}{\St}\quad
      \may{\notype{\C}{\cimbind}}}

\ruleclass{분석 결과의 탐색}{Query}{\type{C}{\querydec}{\VE}}
\rule{\type{C}{\tl{query}\;\ctlbind}{\VE}}
     {\type{C}{\ctlbind}{\VE}}
%      \may{\type{C+\VE}{\query}{\VE'}}}
%\rule{\type{\E}{\ctlbind_1\;\ctlbind_2}{\VE_1+\VE_2}}
%     {\type{\E}{\ctlbind_1}{\VE_1}\quad
%      \type{\E}{\ctlbind_2}{\VE_2}\quad
%      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}

\ruleclass{탐색의 정의}{Query Formula Bind}{\type{C}{\ctlbind}{\VE}}
\rule{\type{C}{\ctlid\;\tl{=}\;\ctl\;\may{\tl{and}\;\ctlbind}}
	   {\{\entry{\ctlid}{\t}\}\;\may{+\VE'}}
     }
     {\type{C}{\ctl}{\t}\quad\may{\type{C}{\ctlbind}{\VE'}}}

\ruleclass{탐색 함수}{Query Formula}{\type{C}{\ctl}{\Lt\to\nt{bool}}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\varlongid_2}{\form/\guard}}
           {\t\to\nt{bool}}}
     {\VE(\varlongid_2)=\t\quad
      \notype{\E+\{\entry{\varid_1}{\t}\}}{\form/\guard}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\tl{pre}\;\varlongid_2}
			 {\form/\guard}}
           {\t'\to\nt{bool}}}
     {\VE(\varlongid_2)=(\t_1,\t_2,p)\quad
      \t' = \t_1\setminus p\quad
      \notype{\E+\{\entry{\varid_1}{\t'}\}}{\form/\guard}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\tl{post}\;\varlongid_2}
		         {\form/\guard}}
           {\t_2\to\nt{bool}}}
     {\VE(\varlongid_2)=(\t_1,\t_2,p)\quad
      \notype{\E+\{\entry{\varid_1}{\t_2}\}}{\form/\guard}}
\rule{\type{C}{\parenIt{\ctl}}{\t\to\nt{bool}}}
     {\type{C}{\ctl}{\t\to\nt{bool}}}

\ruleclass{탐색 식}{Query Expression}{\notype{C}{\form}}
\rule{\notype{C}{\ctlid\;\varid}}
     {\VE(\ctlid) = \t\to\nt{bool}\quad
      \VE(\varid) = \t}
%     {\type{C}{\ctlid\;\varid}{\nt{bool}}}
\rule{\notype{C}{\tl{not}\;\form}}
     {\notype{C}{\form}}
\rule{\notype{C}{\form_1\;(\tl{and}|\tl{or}|\tl{->})\;\form_2}}
     {\notype{C}{\form_1}\quad\notype{C}{\form_2}}
\rule{\notype{C}{(\tl{A}|\tl{E})(\tl{X}|\tl{F}|\tl{G})\;\ctl}}
     {\type{C}{\ctl}{\char`\_}}
\rule{\notype{C}
       {(\tl{A}|\tl{E})\tl{U}\;\tl{(}\;\ctl_1\;\tl{,}\;\ctl_2\;\tl{)}}}
     {\type{C}{\ctl_1}{\char`\_}\quad\type{C}{\ctl_2}{\char`\_}}
\rule{\notype{C}{\parenIt{\form}}}
     {\notype{C}{\form}}

\chapter{\H{프로그램 분석기로의 변환}{Compiling Into Executable Analyzers}}
\H{기획이 제대로 된 분석기는 안전한 nML 프로그램으로 항상 구현될 수 있다.}
{Well-formed Rabbit specification gurantees to transform into typeful nML
programs}:
\NTheorem{Type Safety}{If $\notype{}{\spec}$ then
$\spec\hookrightarrow\nt{topdec}_{\nt{nML}}$ and
for an nML basis $B$, $B\vdash_{\nt{nML}}\nt{topdec}\Rightarrow B'$.}

\ed
