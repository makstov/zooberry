(*
 Kwangkeun Yi, The LET Project, KAIST
   
 Copyright(c) 2000 Research On Program Analysis System 
 National Creative Research Initiative Center
 Korea Advanced Institute of Science & Technology
 http://ropas.kaist.ac.kr

 All rights reserved. This file is distributed under the terms of
 an Open Source License.
*)
(*
 System Zoo
  Constraint-based analysis specification language Beetle
*)

setdec ::= set setbind
setbind ::= setid = setexp

setexp ::=
   /tid/		// nml type id
 | setid                // zoo set id
 | [se,se]		// set of integers from n to m inclusive
 | {eid,...,eid}        // enumerated set
 | power setexp         // power set
 | setexp * setexp      // cartesian product
 | setexp + setexp      // separated sum
 | setexp -> setexp	// set of finite functions
 | cid | cid (setid,...,setid)	// regular tree grammar's right-hand-side

se ::=          // set elmt expression
    /expr/	// nml expr
  | x		// bound name
  | z           // integer
  | se + se	// integer operation
  | eid         // element id
  | {se,...,se} // powerset element
  | se U se	// set union
  | se & se	// set intersection
  | se \ se	// set minus
  | (se,...,se) // product set element
  | se . i      // projection
  | se . setid  // projection
  | se [scmp]   // product modification
  | se : setid  // sum set element: injection/projection
  | {smap,...,smap}  // finite function
  | se @ se     // function image
  | se [smap]   // function modification
  | dom se	// function domain
  | rng se	// function range
  | cid | cid (cvar,...,cvar) // constraint grammar's right-hand-side
  | (se)

scmp ::= i -> se | setid -> se  // product set component
smap ::= se -> se    // an entry
      |   _ -> se    // constant entry

vardec ::= var vars : setexp
vars ::= x | x , vars

constraint ::= cvar >- se
constraints ::= constraint
	      | constraint , constraints
cvar ::= x | x @ se      			// unknowns in program analysis
prule ::= setup constraint			// constraint setup rule
srule ::= rule constraints --+ constraints	// constraint solve rule

(setdec|vardec|prule|srule)+

(*
set R = /expr/ + App(R,R) + Foo(R)

x,y,z: /expr/ -> Val
v    : /id/ -> Val

setup x@/APP(e,e')/ >- app(x@/e/, x@/e'/)

rule 
 id@ >- App(x@,y@)
 x@ >- /LAM(z,e)/
------------------
 id@ >- x@/e/
 v@/z/ >- y@
*)


