%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Kwangkeun Yi & Youil Kim, The LET Project, KAIST
%
% Copyright(c) 2000-2004 Research On Program Analysis System
% National Creative Research Initiative Center
% Korea Advanced Institute of Science & Technology
% http://ropas.kaist.ac.kr
%
% All rights reserved. This file is distributed under the terms of
% an Open Source License.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Kwang's source-editing convention:
% - changed part is surrounded by %(Kwang mm/dd/yy and %)Kwang
% In order to show the kind of a change:
% - added part is surrounded by %(Kadd mm/dd/yy  and  %)Kadd
% - deleted part is surrounded by %(Kdel mm/dd/yy  and  %)Kdel
% - modified part is surrounded by %(Kmod mm/dd/yy  and  %)Kmod
%
% Youil's source-editing convention:
% - changed part is surrounded by %(Youil mm/dd/yy and %)Youil
% In order to show the kind of a change:
% - added part is surrounded by %(Yadd mm/dd/yy  and  %)Yadd
% - deleted part is surrounded by %(Ydel mm/dd/yy  and  %)Ydel
% - modified part is surrounded by %(Ymod mm/dd/yy  and  %)Ymod

\documentclass{report}
\usepackage{proof,xspace,amsmath,latexsym,hangul}
\usepackage{namedcolors}
\usepackage[dvipdf,colorlinks,linkcolor=RawSienna,urlcolor=OliveGreen,breaklinks,backref,pagebackref]{hyperref}

\input{macroRabbit}
%\typein[\lang]{Language? (korean, english, bilingual)}
\let\language\korean
%\let\language\english

\title{프로그램 분석 시스템 {\bf 동물원}\\ Program Analysis System Zoo}
\author{
\href{http://ropas.snu.ac.kr/~kwang}{Kwangkeun Yi} \\
%\href{http://ropas.kaist.ac.kr/~bluewiz}{Youil Kim} \\
%\href{http://ropas.snu.ac.kr/~dreameye}{Yungbum Jung}\\
\href{http://ropas.kaist.ac.kr}{Research On Program Analysis System}\\
Programming Research Laboratory\\
\href{http://ropas.snu.ac.kr}{\tt ropas.snu.ac.kr}\\
\href{http://www.snu.ac.kr}{SNU/KAIST}
}
\date{\today}
\begin{document}
\maketitle
\tableofcontents
%\chapter{\H{동기}{Motivation}}
%\bi
%\item \H{다양한 프로그램 분석기를 쉽게 구현하고 관리하게 해 주는
%         도구가 필요하다. 특히, nML 컴파일러 시스템에서 실제적으로
%         쓰일 수 있는.}  
%        {\\ We need a convenient tool to generate realistic yet
%ambitious program analyzers. We first aim it for being used in our LET
%project, in developing our nML compiler for FCC (fixpoint-carryincd-code).}
%\item \H{프로그램 분석기술을 산업 현장에 전달하는 가장 좋은 방법은
%         쓰기 편한 도구를 제공하는 것이다.}
%        {\\ The best way to transfer our program analysis technology to
%the industry is to provide them with a convenient high-level tool.}
%\ei
%
\chapter{\H{문법구조}{Syntax}}
\section{\H{문법}{Grammar}}
\H{다음의 표기법을 따른다:}{Notation:}
\[
\begin{array}{llcrl}
|	&\mbox{alternative} &\quad & () 	&\mbox{grouping}\\
\la\ra  &\mbox{optional}    &      & \bullet^* & \mbox{zero or more}\\
\bullet^+  &\mbox{one or more} &   & \dagger   &\mbox{sugared alternative}\\
\alpha\nt{row} &\lefteqn{\mbox{one or more $\alpha$'s separated by \tl{,}}}
\end{array}
\]
%\[
%\alpha\nt{row}\; ::=\; \alpha\;|\;\alpha\;\tl{,}\;\alpha\nt{row}
%\]
\[
\begin{array}{rcll}
\nt{integer} &::=& \la\tl{-}\ra(\tl{0}-\tl{9})^+  &\\
	     &|& (\tl{0X}|\tl{0x})
                 (\tl{0}-\tl{9}|\tl{A}-\tl{F}|\tl{a}-\tl{f})^+ &\\
             &|& (\tl{0O}|\tl{0o})(\tl{0}-\tl{7})^+ &\\
             &|& (\tl{0B}|\tl{0b})(\tl{0}-\tl{1})^+ &\\
%\nt{ignore}&::=&\tl{\char`\\}(\nt{newline}|\nt{formfeed}|
%                              \nt{newline}\:\nt{formfeed})
%	       (\nt{space}|\nt{tab})^+ &\\ 
\nt{comment} &::=& \lefteqn{\mbox{balanced \tl{(* *)}, between which
                                  any character can appear.}} &\\
             &| & \lefteqn{\mbox{from \tl{//} to the end of the line}} &\\
&&&\\
\nt{alphanum} &::=&  \tl{a}-\tl{z}\:|\:\tl{A}-\tl{Z}\:|\:\nt{hangul}
		\:|\:\tl{0}-\tl{9}\:|\:\tl{\char`\_}\:|\:\tl{'} & \\
\nt{upper} &::=& \tl{A}-\tl{Z}\:|\:\tl{\char`\_} &\\
\nt{lower} &::=& \tl{a}-\tl{z}\:|\:\nt{hangul} &\\
\nt{hangul} &::=& \lefteqn{
		   \mbox{syllables of KSX1001 (a.k.a. KSC5601 or eur-kr)}} \\
       & |&\lefteqn{\mbox{syllables of KSX1005-1
                          (a.k.a. KSC5700, unicode, or ISO/IEC10646-1)}}\\
\nt{sym} &::=& \lefteqn{
		\tl{!}\:|\:\tl{\%}\:|\:\tl{\char`\&}\:|\:\tl{\char`\$}
                \:|\:\tl{\char`\#}\:|\:\tl{+}\:|\:\tl{-}\:|\:\tl{/}\:|\:\tl{:}
		\:|\:\tl{<}\:|\:\tl{=}\:|\:\tl{>}\:|\:\tl{?}\:|\:\tl{@}\:|
		\:\tl{\char`\\}\:|\:\tl{\char`\~}\:|\:\tl{`}\:|
		\:\tl{\char`\^}\:|\:\tl{|}\:|\:\tl{*}
		}\\
%\end{array}
%\]
%\[
%\begin{array}{rcll}
\nt{lid} &::= &\nt{lower}(\nt{alphanum})^* & \\
\nt{uid} &::= &\nt{upper}(\nt{alphanum})^* & \\
\nt{sid} &::= & \nt{sym}\nt{sym}^+ &\\
\nt{id} &::= &\nt{lid}\;|\;\nt{uid}\;|\;\nt{sid} &\\
\varid &::=& \nt{id}	& \\
\ctlid &::=& \nt{id}	& \\
%\nt{prefixid} &::=& (\tl{!}\:|\:\tl{?}\:|\:\tl{\char`\~})\nt{sym}^* &\\
\elmtid&::=& \nt{id}	&\\
\setid&::=&  \nt{uid}	&\\
\latid&::=&  \nt{uid}	&\\
\domid&::=&  \setid\:|\:\latid	&\\
\anaid&::=& \nt{id} &\\
\sigid&::=& \nt{id} &\\
\temid&::=& \nt{id} &\\
\cvarid&::=& \nt{id} &\\
\conid&::=& \nt{id} &\\
\alpha\nt{longid} &::=&\alpha\nt{id}\;\;|\;\;\nt{anaid}.\alpha\nt{id} &\\
\end{array}
\]

\[
\begin{array}{rcll}
%\topdec &::=& \adec &\\
\topdec &::=& \anadec &\\
	&|& \sigdec &\\
	&|& \temdec &\\
	&|& \topdec_1\;\topdec_2 &\\
&&&\\
\adec &::=& \domdec &\\
	&|& \semdec &\\
	&|& \querydec &\\
	&|& \adec_1\;\adec_2 &\\
&&&\\
%\anadec &::=& \tl{analysis}\;\anabind &\\
%\anabind &::=& \anaid\;\tl{=}\;\anaexp &\\
\anadec &::=& \tl{analysis}\;\anaid\;\tl{=}\;\anaexp &\\
\anaexp &::=& \tl{ana}\;\adec\;\tl{end} &\\
	&|& \temid\;\tl{(}\anaexprow\tl{)} &\\
	&|& \anaid &\\
&&&\\
%\sigdec &::=& \tl{signature}\;\sigbind &\\
%\sigbind &::=& \sigid\;\tl{=}\;\sigexp &\\
\sigdec &::=& \tl{signature}\;\sigid\;\tl{=}\;\sigexp &\\
\sigexp &::=& \tl{sig}\;\adesc\;\tl{end} &\\
	&|& \sigid &\\
&&&\\
%\temdec &::=&\tl{analysis}\;\tembind &\\
%\tembind &::=&\temid\tl{(}(\anaid\;\tl{:}\;\sigexp)\nt{row}\tl{)}\;
%		\tl{=}\;\tl{ana}\;\adec\;\tl{end} &\\
\temdec &::=&\tl{analysis}\;
                \temid\tl{(}(\anaid\;\tl{:}\;\sigexp)\nt{row}\tl{)}\;
		\tl{=}\;%\tl{ana}\;\adec\;\tl{end} &\\
                        \anaexp &\\
&&&\\
\adesc
&::=&\tl{set}\;\setdesc &\\
 &|& \tl{lattice}\;\latdesc &\\
 &|& \tl{val}\;\varid\;\tl{:}\;\ty &\\
 &|& \tl{eqn}\;\varid\;\tl{:}\;\ty &\\
 &|& \tl{query}\;\ctlid\;\tl{:}\;\ty &\\
 &|& \adesc_1\;\adesc_2 &\\
 &\sugar&\tl{set}\;\setdesc\nt{row} &\\
 &\sugar&\tl{lattice}\;\setdesc\nt{row} &\\
\setdesc &::=& \setid\;\;|\;\;\kindIt{\setid}{\kind}\;\;|\;\;\setbind &\\
\latdesc &::=& \latid\;\;|\;\;\kindIt{\latid}{\kind}\;\;|\;\;\latbind &\\

\end{array}
\]
\[
\begin{array}{rcll}
\domdec &::=& \setdec\;|\;\latdec\;|\;\nt{winadec}&\\
%	&|& \domdec_1\;\domdec_2 &\\
\setdec &::=& \tl{set}\;\setbind &\\
%        &|& \setdec_1\;\setdec_2 &\\
\setbind &::=& \setid\;\tl{=}\;\setexp &\\
\setexp
%(Kmod 10/18/02
 &::=&\tl{/}\tylongid\tl{/} %\;|\;\tl{/}\strlongid\tl{/}
     &\mbox{nML type id}\\
%)Kmod
 &|&\setlongid				& \mbox{set id}\\
 &|&\braceExp{\eO\;\tl{...}\;\eT}	& \mbox{integer interval set}\\
 &|&\braceExp{\elmtidrow} 		& \mbox{enumerated set}\\
 &|&\tl{power}\;\setexp 		& \mbox{power set}\\
 &|&\setexp_1\;\tl{*}\;\setexp_2	& \mbox{cartesian product}\\
 &|&\setexp_1\;\tl{+}\;\setexp_2	& \mbox{separated sum}\\
 &|&\setexp_1\;\tl{->}\;\setexp_2	& \mbox{finite function set}\\
 &|&\setexp\;\tl{constraint}\;\cnstdec	& \mbox{constraint set}\\
 &|&\parenIt{\setexp}	&\\
\cnstdec &::=& \tl{var = }\braceExp{\cvaridrow}\;\may{\tl{index}\;\setexp}&\\
         &   & \tl{rhs = }\rhs &\\
% \cnstdec &::=& \cvarid\;\may{\tl{index}\;\setexp}\;\tl{<-}\;\rhs
% 		\;\may{\tl{and}\;\cnstdec} 	&\\
%\rhs &::=&\cvar\;\may{\tl{|}\;\rhs} &\\
%     &|& \conid\;\may{\carg}\;\may{\tl{:}\;\tl{atomic}}
%	       \;\may{\tl{|}\;\rhs}		&\\
\rhs &::=&\cvar &\\
      &|& \conid\;\may{\carg}\;\may{\tl{:}\;\tl{atomic}} &\\
      &|&\rhs_1\;\tl{|}\;\rhs_2 &\\
\cvar &::=&\tl{var}\;|\;\tl{var}\;\setlongid &\\
\carg &::=&\cvar &\\
      &|& \setexp &\\
      &|& \tl{(}\;\cargrow\;\tl{)} &\\
 &&&\\
\latdec &::=&\tl{lattice}\;\latbind &\\
%        &|& \latdec_1\;\latdec_2 &\\
\latbind&::= &\latid\;\tl{=}\;\latexp &\\
\latexp &::=&\tl{/}\strlongid\tl{/} & \mbox{nML structure id}\\
  &|&\latlongid			 & \mbox{lattice id}\\
  &|&\tl{flat}\;\setexp          & \mbox{flat lattice}\\
  &|&\tl{power}\;\setexp         & \mbox{powerset lattice}\\
  &|&\latexp_1\;\tl{*}\;\latexp_2  & \mbox{cartesian product}\\
  &|&\latexp_1\;\tl{+}\;\latexp_2  & \mbox{coalesced sum}\\       
  &|&\latexp_1\;\tl{->}\;\latexp_2 & \mbox{atomic function lattice}\\
  &|&\setexp\;\tl{->}\;\latexp & \mbox{dependent product lattice}\\
%(Ymod 11/04/02
  &|&\tl{order}\;\setexp\;\tl{with}\;\nt{jmdec}\;\may{\nt{jmdec}}
          &\mbox{lattice with an explicit join/meet}\\
%)Ymod
  &|&\parenIt{\latexp}	&\\
\nt{jmdec}&::=& \tl{join}\;\match &\mbox{user-defined join operator}\\
          & | & \tl{meet}\;\match &\mbox{user-defined meet operator}\\
%\nt{order}&::=& \nt{po}\;\nt{pat} &\mbox{chain}\\
%          &|& \nt{order}_1\;\tl{|}\;\nt{order}_2\\
%          &\sugar& \nt{pat}\;(\nt{po}\;\nt{pat})^+ &\\
%\nt{po} &::=&\tl{<}\;\; |\;\;\tl{>} &\mbox{partial order}\\
&&&\\
\nt{winadec} &::=&\tl{widen}\;\latid\;\tl{with}\;\match &\\
             & | &\tl{narrow}\;\latid\;\tl{with}\;\match &\\
&&&\\
\kind &::=&\tl{syntree}\;|\;\tl{index}\;|\;\tl{integer}\;|\;\tl{power}&\\
      & | &\tl{sum}\;|\;\tl{product}\;|\;\tl{arrow}&\\
\end{array}
\]
\[
\begin{array}{rcll}
\semdec &::=&\valdec &\\
          &|&\eqndec &\\
          &|&\ccrdec &\\
          &|&\cimdec &\\
%	  &|&\semdec_1\;\semdec_2 &\\
&&&\\
\valdec&::=& \tl{val}\;\vbind	&\mbox{auxiliary semantic value}\\
     &|&\tl{val rec}\;\vbind	&\mbox{auxiliary semantic value}\\
     &\sugar&\tl{fun}\;\fbind	&\\
     &\sugar&\tl{map}\;\fbind 	&\\
\vbind &::=& \pat\;\tl{=}\;\e\;\may{\tl{and}\;\vbind} &\\
\fbind &::=&
	 \varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	 \varid\;\pat\;\tl{=}\;\e &\\
       & & \may{\tl{and}\;\fbind} &\\
&&&\\      
\eqndec&::=&\tl{eqn}\;\ebind &\mbox{semantic equation}\\
         &|&\tl{eqn rec}\;\ebind &\mbox{semantic equation}\\
    &\sugar&\tl{eqn}\;\efbind &\\
\ebind  &::=&\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind} &\\
\efbind &::=&\varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
	     \varid\;\pat\;\tl{=}\;\e &\\
        &   &\may{\tl{and}\;\efbind} &\\
&&&\\
\ccrdec &::=&\tl{ccr}\;\ccrbind & \mbox{constraint closure rule}\\
\ccrbind &::=&\cnstguard\;\tl{----}^+\;\constraintrow\;\may{\tl{|}\;\ccrbind} &\\
\cnstguard &::=& \constraint &\\
           & | & \guard &\\
           & | & \cnstguard_1\;\tl{,}\;\cnstguard_2 &\\
\constraint &::=& \cvarexp\;\tl{<-}\;\rhsexp &\\
	&\sugar&  \cvarexp\;\tl{<-}\;\rhsexp\;(\tl{+}\;\rhsexp)^+ &\\
\rhsexp &::=&\cvarexp &\\
        &|& \conlongid\;\may{\cargexp} &\\
\cargexp &::=& \cvarexp &\\
      &|& \pat &\\
      &|& \tl{(}\;\cargexprow\;\tl{)} &\\
\cvarexp &::=& \cvarlongid\;|\;\indexExp{\cvarlongid}{\pat} &\\
&&&\\
\cimdec &::=&\tl{cim}\;\cimbind
        &\mbox{constraint conid's image declaration}\\
\cimbind &::=& \conlongid\;\may{pat}\;\tl{=}\;\e\;\may{\tl{|}\;\cimbind} &\\
%\ebind  &::=&\may{\kind}\;\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind} &\\
%\efbind &::=&\may{\kind}\;\varid\;\pat\;\tl{=}\;\e \;\tl{|}\cdots\tl{|}
%	     \varid\;\pat\;\tl{=}\;\e &\\
%        &   &\may{\tl{and}\;\efbind} &\\
%\kind &::=& \nt{syntreekind}\;\nt{indexkind} &\\
%      &|&\nt{indexkind}\;\nt{syntreekind} &\\
%      &|&\parenIt{\kind} &\\
%      &\sugar&\nt{syntreekind} &\\
%\nt{syntreekind} &::=& \tl{set}\;\setid\;\tl{:}\;\tl{syntree} &\\
%\nt{indexkind} &::=&\tl{set}\;\setid\;\tl{:}\;\tl{index} &
\end{array}
\]
\[
\begin{array}{rcll}
\e&::=& \tl{/}\nexp\tl{/}	&\mbox{nML expr}\\
 & |& \setlongid      		&\mbox{set itself}\\
 & |& \constant			&\mbox{constant}\\
 & |& \varlongid		&\mbox{bound id}\\
 & |& \constraint		&\mbox{constraint}\\
 & |& \eO\;\bop\;\eT 		&\mbox{binary op}\\
 & |& \braceExp{\eO\;\tl{...}\;\eT} 		& \mbox{integer set}\\
 & |& \braceExp{\erow}		&\mbox{set}\\
 & |& \setcomExp{\erow}{\qual}	&\mbox{set comprehension}\\
 & |& \braceExp{\mrulerow}      &\mbox{map}\\
 & |& \setcomExp{\mrulerow}{\qual} &\mbox{map comprehension}\\
 & |& \tl{\char`\{\char`\}}	&\mbox{empty set/map}\\
 & |& \foldExp{\tl{+}}{\e}      &\mbox{fold join}\\
 & |& \foldExp{\tl{*}}{\e}      &\mbox{fold meet}\\
 & |& \tupleExp{\e_1}{\e_2}	&\mbox{tuple}\\ 
 & |& \projExp{\e}{\tl{1}}\;\;|\;\;\projExp{\e}{\tl{2}}	&\mbox{projection}\\ 
% & |& \injExp{\e}{\ty}{\tl{1}}\;\;|\;\;\injExp{\e}{\ty}{\tl{2}}
%				&\mbox{injection}\\
 & |& \letExp{\valdec}{\e}	&\mbox{local expr}\\
 & |& \fnExp{\match}		&\mbox{abstraction}\\
 & |& \appExp{\eO}{\eT} 	&\mbox{application or map image}\\
 & |& \parenExp{\e}		&\\
 & |& \coerceExp{\e}{\ty}	&\mbox{coercion}\\
 & |& \indexExp{\may{\tl{pre}\:|\:\tl{post}}\;(\varlongid|\cvarlongid)}{e} 
	&\mbox{solution look-up}\\
% & |& \solutionExp{\tl{post}\;\varlongid}{e} &\mbox{solution look-up}\\
 &\sugar&\tupleExp{\e}{\erow}	&\mbox{tuple}\\
 &\sugar&\projExp{\e}{\domlongid}	&\mbox{projection}\\
 &\sugar&\modiExp{\e}{\mrule}	&\mbox{modifying map}\\
% &\sugar&\modiExp{\eO}{\domid\;\tl{=>}\;\eT} &\mbox{modifying tuple}\\
 &\sugar&\mpExp{\match} 	&\mbox{map}\\
 &\sugar&\caseExp{\e}{\match} 	&\mbox{branch}\\
 &\sugar&\ifExp{\eO}{\eT}{\eR} &\mbox{branch}\\
 &\sugar&\mapExp{\eO}{\eT} &\mbox{mapping}\\
\bop &::= & \tl{+}\;|\;\tl{*}\;|\;\tl{-} &\mbox{join, meet, set-minus}\\
     &|&    \rop 			 &\mbox{relational operators}\\
\constant &::=& \nt{integer}   	&\\
 &|&\elmtlongid		&\mbox{set element id}\\
 &|&\tl{top}		&\mbox{lattice top}\\
 &|&\tl{\char`\^}	&\mbox{lattice top}\\
 &|&\tl{bottom}		&\mbox{lattice bottom}\\
 &|&\tl{\char`\_\char`\_}	&\mbox{lattice bottom}\\
 &|&\tl{true}	&\\
 &|&\tl{false}	&\\
%\nt{ne} &::=& \rabbitId{\varlongid}	&\mbox{embedded rabbit id}\\
%        &|&   \nt{nmlexp} &\mbox{nML expr with embedded rabbit id}\\
\ty &::=&\tl{int}\;|\;\domlongid\;|\;\tl{/}\nt{tylongid}\tl{/} &\\
    & | &\ty_1\;\tl{*}\;\ty_2\;|\;\ty_1\;\tl{+}\;\ty_2 &\\
    & | &\ty_1\;\tl{->}\;\ty_2\;|\;\tl{power}\;\ty
%(Kadd 10/19/02
\;|\;\tl{flat}\;\ty &\\
%)Kadd
    & | &\parenIt{\ty} &\\
    & | &\kindIt{\ty}{\kind} &\\
%    & | &\parenExp{\ty\;\tl{,}\;\tl{1}}\;|\;\parenExp{\ty\;\tl{,}\;\tl{2}}&
\end{array}
\]
\[
\begin{array}{rcll}
\qual &::=& \gen\;\may{\tl{,}\;\guard} &\\
\gen &::=&\genPat{\pat}{\e}        &\mbox{for each element of a set}\\
     &|&\genPat{\mpat}{\e}  &\mbox{for each entry of a map}\\
     &|&\gen_1\;\tl{,}\;\gen_2 &\\
\guard &::=&\eO\;\rop\;\eT	   	 &\mbox{relation}\\
       & |& \eO\;\tl{in}\;\eT		 &\mbox{membership}\\
       & |& \tl{not}\;\guard		 &\\
       & |& \guard_1\;\tl{and}\;\guard_2 &\\
       & |& \guard_1\;\tl{or}\;\guard_2  &\\
       & |& \forallGuard{\gen}{\guard}		&\mbox{for all}\\
       & |& \forsomeGuard{\gen}{\guard}		&\mbox{for some}\\
       & |& \parenIt{\guard}		&\\
       &\sugar& \guardrow	&\mbox{conjunction}\\
\rop &::=& \tl{<} \;|\; \tl{>} \;|\; \tl{=} \;|\; \tl{<=} \;|\; \tl{>=} &\\
&&&\\
\match &::=& \mrule\;\may{\tl{|}\;\match} &\\
\mrule &::=& \pat\;\tl{=>}\;\e &\\
\pat &::=& \tl{/}\nt{npat}\tl{/}		&\mbox{nML pattern}\\
     & |& \tl{\char`\_}		&\mbox{wild pattern}\\
     & |& \varid		&\mbox{pattern var}\\
     & |& \braceExp{\patrow\; \may{\tl{...}}}  	&\mbox{set pattern}\\
     & |& \braceExp{\pat_1\;\tl{...}\;\pat_2}	&\mbox{interval set pattern}\\
     & |& \braceExp{\mpatrow\; \may{\tl{...}}}  &\mbox{map pattern}\\
%(Kdel 10/14/02
%     & |& \injExp{\pat}{\ty}{\tl{1}|\tl{2}}	&\mbox{injection pattern}\\
%)Kdel
     & |& \tupleExp{\pat_1}{\pat_2} 	&\mbox{tuple pattern}\\
     & |& \guardPat{\pat}{\guard}  &\mbox{guarded pattern}\\
     & |& \orPat{\pat_1}{\pat_2}   &\mbox{or pattern}\\
     & |& \asPat{\varid}{\pat}     &\mbox{as pattern}\\
     & |& \coerceExp{\pat}{\ty}    &\\
     & |& \parenIt{\pat} &\\
     &\sugar& \constant   &\mbox{const pattern}\\
     &\sugar& \tupleExp{\pat}{\patrow} 	&\mbox{tuple pattern}\\
%     &\sugar& \braceExp{(\domid\;\tl{=>}\;\pat)\nt{row}
%                        \;\la\tl{...}\ra
%                       } & \mbox{tuple pattern}\\
     &\sugar&\ropPat{\pat}{\e}		&\mbox{relation pattern}\\
     &\sugar&\memberPat{\pat}{\e}	&\mbox{member pattern}\\

\mpat &::=&\pat\;\tl{=>}\;\pat &
\end{array}
\]
\[
\begin{array}{rcll}
\querydec&::=&\tl{query}\;\ctlbind&\\
\ctlbind &::=& \ctlid\;\tl{=}\;\ctl\;\may{\tl{and}\;\ctlbind}&\\
\ctl  &::=&\boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;\varid}
		    {(\form|\guard)}
	  &\mbox{CTL formula with a binder}\\
       &|& \boundCtl{\varid\;\tl{:}\;\may{\tl{pre}|\tl{post}}\;
                     \tl{(}\anaid\tl{.}\varid\tl{)}}
                    {(\form|\guard)}
	  &\mbox{CTL formula with a binder}\\
       &|& \parenIt{\ctl} &\\
\form &::=& \ctlid\;\varid	&\mbox{ctl application}\\
      &|&\tl{not}\;\form        &\\
      &|&\form_1\;\tl{and}\;\form_2 &\\
      &|&\form_1\;\tl{or}\;\form_2  &\\
      &|&\form_1\;\tl{->}\;\form_2  &\mbox{implication}\\
      &|&\upath\;\ctl		&\mbox{unary path formula}\\
      &|&\bpath\;\parenIt{\ctl_1\;\tl{,}\;\ctl_2} &\mbox{binary path formula}\\
      &|&\parenIt{\form}	&\\
      &\sugar& \form_1\;\tl{<->}\;\form_2 &\mbox{equivalence}\\
\upath &::=&\tl{AX}\;|\;\tl{AF}\;|\;\tl{AG} &\\
      & | &\tl{EX}\;|\;\tl{EF}\;|\;\tl{EG} &\\
\bpath &::=&\tl{AU}\;|\;\tl{EU} &\mbox{until}
\end{array}
\]


\newpage
\section{\H{설탕 구조}{Syntactic Sugars}}
\H{자유로운 이름이 설탕이 녹으면서 묶이지 않도록 한다.}
{Free identifiers must not be bound in the de-sugar'ed definitions.}
\[
\begin{array}{lcll}
\lefteqn{\tl{set}\;\setdesc_1\tl{,}\cdots\tl{,}\setdesc_n}\\
&\equiv& \lefteqn{
         \tl{set}\;\setdesc_1\;\cdots\;\tl{set}\;\setdesc_n
         }\\
\lefteqn{\tl{lattice}\;\latdesc_1\tl{,}\cdots\tl{,}\latdesc_n}\\
&\equiv& \lefteqn{
         \tl{lattice}\;\latdesc_1\;\cdots\;\tl{lattice}\;\latdesc_n
         }\\
%\lefteqn{Order}\\

%(Kdel 10/17/02
%\nt{pat}\;\nt{po}_1\;\nt{pat}_1\cdots\nt{po}_n\;\nt{pat}_n
%&\equiv& \lefteqn{
%         \nt{po}_1\;\parenIt{\nt{pat}\tl{,}\nt{pat}_1}\;\tl{|}\cdots\tl{|}\;
%         \nt{po}_n\;\parenIt{\nt{pat}_{n-1}\tl{,}\nt{pat}_n}
%         }
%\\
%)Kdel

%\lefteqn{Expression}\\
\parenIt{\e_1\tl{,} \e_2\tl{,} \e_3}
&\equiv& \parenIt{\e_1\tl{,}\parenIt{\e_2\tl{,} \e_3}} &
\\
\projExp{\e}{\domlongid}
\mbox{\ as\ }\projExp{\e}{\cdots.\domid}
&\equiv&
\lefteqn{\projExp{\e}{\tl{k}}\quad
         \mbox{$\e: D=A_1\times\cdots\times A_n$ and $\domid = A_k$}
        }
\\
\modiExp{\e}{\pat\;\tl{=>}\;\e'}
&\equiv&\braceExp{\pat\;\tl{=>}\;\e'\;\tl{,}\;\tl{x}\;\tl{=>}\;\e\:\tl{x}} &
 \mbox{new \tl{x}}
\\
\mpExp{\mrule_1\;\tl{|}\cdots\tl{|}\;\mrule_n}
&\equiv&\braceExp{\mrule_1\;\tl{,}\cdots\tl{,}\;\mrule_n} &
\\
\caseExp{\e}{\match} &\equiv&\parenIt{\fnExp{\match}}\;\e &
\\
\ifExp{\eO}{\eT}{\eR} &\equiv&\lefteqn{
\caseExp{\eO}{\tl{true}\;\tl{=>}\;\eT\;\tl{|}\;\tl{false}\;\tl{=>}\;\eR}
}
\\
\mapExp{\eO}{\eT} &\equiv&\lefteqn{
\setcomExp{\eO\;\tl{x}}{\genPat{\tl{x}}{\eT}}
}
\\
\guard_1\;\tl{,}\;\guard_2 &\equiv&\guard_1\;\tl{and}\;\guard_2 &
\\
\cvarexp\;\tl{<-}\;\rhsexp_1\;\tl{+}\;\rhsexp_2 &\equiv&\lefteqn{
\cvarexp\;\tl{<-}\;\rhsexp_1\;\tl{,}\;\cvarexp\;\tl{<-}\;\rhsexp_2}
\\
%\lefteqn{Pattern}\\
\tupleExp{\pat_1}{\pat_2\;\tl{,}\;\pat_3}
&\equiv&\tupleExp{\pat_1}{\tupleExp{\pat_2}{\pat_3}} &
\\
\constant &\equiv & \guardPat{\tl{x}}{\tl{x = }\constant} &
\mbox{new \tl{x}}
\\
\ropPat{\pat}{\e} &\equiv&\guardPat{\asPat{\tl{x}}{\pat}}{\tl{x}\;\rop\;\e} &
\mbox{new \tl{x}}
\\
\memberPat{\pat}{\e}&\equiv&\guardPat{\asPat{\tl{x}}{\pat}}{\tl{x in \e}} &
\mbox{new \tl{x}}
\\
%\lefteqn{Declaration}\\
\lefteqn{
\tl{fun}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
          \tl{val rec}\;\varid\;\tl{= fn}\;
          \pat_1\;\tl{=>}\;\e_1\;\tl{|}\;\pat_2\;\tl{=>}\;\e_2
        }
}
\\
\lefteqn{
\tl{map}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
         \tl{val}\;\varid\;\tl{=}\;
         \braceExp{\pat_1\;\tl{=>}\;\e_1\;\tl{,}\;\pat_2\;\tl{=>}\;\e_2}
         }
}
\\
\lefteqn{
\tl{eqn}\;\varid\;\pat_1\;\tl{=}\;\e_1 \;\tl{|}\;\varid\;\pat_2\;\tl{=}\;\e_2
\;\equiv\;\lefteqn{
          \tl{eqn rec}\;\varid\;\tl{= fn}\;
          \pat_1\;\tl{=>}\;\e_1 \;\tl{|}\;\pat_2\;\tl{=>}\;\e_2
        }
}
\\
%%\lefteqn{Kind}\\
%\tl{set}\;\setid\;\tl{:}\;\tl{syntree}
%&\equiv& \lefteqn{
%          \tl{set}\;\setid\;\tl{:}\;\tl{syntree}\;
%          \tl{set}\;\setid\;\tl{:}\;\tl{index}
%         } &
%\\
%\lefteqn{CTL Formula}\\
\form_1\;\tl{<->}\;\form_2
&\equiv&\lefteqn{
         \form_1\;\tl{->}\;\form_2\;\tl{and}\;
         \form_2\;\tl{->}\;\form_1
        } &
\\
\end{array}
\]

%\section{\H{기본 타입과 연산자}{Primitive Types and Operators}}
%\bi
%\item \H{기본 타입}{Primitive types}:
%\tl{int}, \tl{bool}
%\item \H{기본 연산자}{Primitive operators}:
%
%\begin{tabular}{|r|l|l|}\hline
%\tl{+},\tl{-},\tl{*},\tl{/}
%     & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int add/sub/mul/div\\
%%\tl{+} & (prefix) $\tl{int}\to\tl{int}$ & identity\\
%%\tl{-} & (prefix) $\tl{int}\to\tl{int}$ & int negation\\
%%       & (prefix) $\tl{real}\to\tl{real}$ & real negation\\
%\tl{div} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int division\\
%\tl{mod} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int modulus\\
%\tl{**} & (infix) $\tl{int}\times\tl{int}\to\tl{int}$ & int exponential\\
%\hline
%\end{tabular}
%
%\ei
%
\section{\H{우선순위와 방향성}{Precedences and Associativity}}
\bi
\item \H{도메인 식에서의 우선순위(내림차순)와 방향성}
  {Constructs' precedence (in decreasing order) and associativity}

 \begin{tabular}{|l|c|}  \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{power},\tl{flat}$ & right \\ \hline
 $\tl{*}$ & right \\ \hline
 $\tl{+}$ & left \\ \hline
 $\tl{->}$ & right \\ \hline
%(Ymod 11/04/02
 $\tl{order}$ & -- \\ \hline
%)Ymod
 \end{tabular}

\item \H{분석 식에서의 우선순위(내림차순)와 방향성}
  {Constructs' precedence (in decreasing order) and associativity}

 \begin{tabular}{|l|c|}  \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 \tl{@} & left \\ \hline
 $\tl{.}$ & left \\ \hline
 $\tl{[}\mrule\tl{]}$ & left \\ \hline
 application & left \\ \hline
 $\tl{+}$ (prefix), $\tl{*}$ (prefix) & right \\ \hline
 $\tl{*}$ (infix) & left \\ \hline
 $\tl{+}$ (infix), $\tl{-}$ (infix) & left \\ \hline
 $\tl{<}$,$\tl{>}$,$\tl{=}$,$\tl{<=}$,$\tl{>=}$ & left \\ \hline
 $\tl{not}$ & right \\ \hline
 $\tl{and}$ & right \\ \hline
 $\tl{or}$  & right \\ \hline
 $\tl{in}$ & right \\ \hline
 $\tl{,}$ & left \\ \hline
 $\tl{:}$ & left \\ \hline
 $\tl{case}$, $\tl{fn}$, $\tl{mp}$ & right \\ \hline
 \end{tabular}

\item
\H{패턴에서의 우선순위(내림차순)와 방향성}
  {Pattern constructs' precedence (from higher to lower) and associativity}

 \begin{tabular}{|l|c|} \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{:}$ & left \\ \hline
 $\tl{as}$ & left \\ \hline
 $\tl{with}$ & left \\ \hline 
 \end{tabular}

\item
\H{탐색 식에서의 우선순위(내림차순)와 방향성}
  {CTL formula constructs' precedence (from higher to lower) and associativity}

 \begin{tabular}{|l|c|} \hline
 \mc{1}{|c|}{constructs} & \mc{1}{|c|}{associativity} \\ \hline \hline
 $\tl{not}$ & right \\ \hline
 $\tl{and}$ & left \\ \hline
 $\tl{or}$ & left \\ \hline
 $\tl{->}$ & left \\ \hline
 ($\tl{A}|\tl{E}|\tl{U}$)($\tl{X}|\tl{F}|\tl{G}$) & right \\ \hline
 \end{tabular}

\ei

\section{\H{예약된 심볼들}{Reserved words}}
\begin{verbatim}

analysis  ana  end  signature  sig   set  lattice  atomic  val  eqn  query
power  constraint  index  var  rhs  flat  order  join  meet  widen  narrow  
with  syntree  index  integer sum  product  arrow  val  rec  fun  map  ccr  
cim  and  pre  post  top  bottom  true false int  not  or  let  in  fn  mp  
case  of  as  from  widen  AX  AF  AG  AU  EX  EF  EG  EU  (  )  :  |  {  }  
...  *  +  ->  <- <  >  [  ]  =>  _  !  ?  .  ,  =  <=  >=  <->  @  ^  __ 
\end{verbatim}

\section{\H{문법적인 제약들}{Syntactic Constraints}}
\bi

\item \H{집합과 래티스에서 재귀적인 선언은 불가능하다. 스스로
재귀적이던가 몇개서 서로 재귀적으로 물려서 선언되는 것은 없다.
이 제약조건은 집합과 래티스는 각각 nML의 한 모듈로 컴파일되는 데,
nML에서는 상호 재귀적인 모듈선언이 불가능 하기 때문이다.}
{Sets and lattices cannot be defined recursively.}

\item \H{as-패턴과 with-패턴이 녹을 수 있는 설탕이기 위해서는 패턴이 
계산식(expression)의 형태를 가지고 있어야 한다. 예를들어,
\tl{\char`\_}(wildcard)가 패턴에 있으면 않된다.}
{No wildcard pattern is allowed in both the \tl{as}-pattern and
\tl{with}-pattern. Because the patterns must be legal as expressions.} 

\item \H{제약식 선언($\cnstdec$)에서 선언되는 제약식
함수심볼($\conid$)들과 제약식 변수($\cvarid$)들은 모두 달라야 한다.}
{In a constraint set declaration, every constraint function symbol
$\conid$ and constraint variable $\cvarid$ must be distinct.}

\item \H{제약식 푸는 규칙($\ccrdec$)에서 하나의
제약식($\constraint$)이나 조건절($\guard$)에서 사용되는 패턴 변수들은
모두 달라야 한다.}{For a constraint closure rule ($\ccrdec$), every
pattern variable in each constraint or guard must be distinct.}

\ei

\section{\H{예}{Rabbit examples}}
\bi
\item Simultaneous equations:
{\footnotesize
\begin{verbatim}
analysis Eqn =
 ana
   lattice A = power {a,b,c,d}

   eqn x1 = x2 + x3 * {a,b}
   and x2 = {b,c} * x3
   and x3 = x1 + x2
 end
\end{verbatim}
}

\item 0CFA analysis for lambda calculus in the abstract interpretation style:

{\footnotesize
\begin{verbatim}
analysis TinyCfa =
 ana
    set Var = /Exp.var/
    set Lam = /Exp.expr/
    lattice Val = power Lam
    lattice State = Var -> Val

    widen Val with {/Lam(x,Lam _)/ ...} => top

    eqn E(/x/,s) = s /x/
      | E(/Lam(x,e)/, s) = {/Lam(x,e)/}
      | E(/App(e1,e2)/, s) = let val lams = E(/e1/, s)
                                 val v = E(/e2/, s) 
                             in
                              +{ E(/e/,s+bot[/x/=>v]) | /Lam(x,e)/ from lams } 
                             end
 end
\end{verbatim}
}

\item 0CFA analysis for lambda calculus in Heintze's style
constraint-based analysis (a.k.a. set-based analysis)

{\footnotesize
\begin{verbatim}
analysis Sba = 
 ana
   set Var = /Ast.id/
   set Exp = /Ast.exp/
   set Val = power Exp
             constraint
               var = {X} index Var + Exp
               rhs = var
                   | app(var, var)
                   | lam(Var, Exp) : atomic

   (* constraint collection *)

   eqn Col /Ast.Var(x)/ = {}
     | Col /Ast.Lam(x,body) as e/ = { X@/e/ <- lam(/x/,/body/) }
                                  + Col /body/
     | Col /Ast.App(e,e') as e/ = { X@/e/ <- app(X@/e/, X@/e'/) }
                                  + Col /e/ + Col /e'/

   (* constraint closure rule *)

   ccr   X@a <- app(X@b, X@c), X@b <- lam(/x/, /body/)
         -----------------------------------------
         X@a <- X@/body/, X@/x/ <- X@c 
 end
\end{verbatim}
}

\item Exception analysis for ML core, parameterized by a CFA:

{\footnotesize
\begin{verbatim}
signature CFA = sig
                  lattice Env
                  lattice Fns = power /Ast.exp/
                  eqn Lam: /Ast.exp/:index * Env -> Fns
                end

analysis ExnAnal(Cfa: CFA) =
 ana
   set Exp = /Ast.exp/
   set Var = /Ast.var/
   set Exn = /Ast.exn/
   set UncaughtExns = power Exn 
                      constraint
                      var = {X, P} index Var + Exp
                      rhs = var
                          | app_x(/Ast.exp/, var)
                          | app_p(/Ast.exp/, var)
                          | exn(Exn)                         : atomic
                          | minus(var, /Ast.exp/, power Exn) : atomic
                          | cap(var, /Ast.exp/, Exn)         : atomic

   (* constraint collection equation *)

   eqn Col /Ast.Var(x)/ = {}
     | Col /Ast.Const/ = {}
     | Col /Ast.Lam(x,e)/ = Col /e/
     | Col /e as Ast.Fix(f,x,e',e'')/ = Col /e'/ + Col /e''/
                                      + { X@/e/ <- X@/e''/, P@/e/ <- P@/e''/ }
     | Col /e as Ast.Con(e',k)/ = Col /e'/
                                + { X@/e/ <- exn(/k/), P@/e/ <- P@/e'/ }
     | Col /e as Ast.Decon(e')/ = Col /e'/
                                + { X@/e/ <- X@/e'/, P@/e/ <- P@/e'/ }
     | Col /e as Ast.Exn(k,e')/ = Col /e'/
                                + { X@/e/ <- exn /k/, X@/e/ <- X@/e'/ }
     | Col /e as Ast.App(e',e'')/ = Col /e'/ + Col /e''/
                                + { X@/e/ <- app_x(/e'/, X@/e''/),
                                    P@/e/ <- app_p(/e'/, X@/e''/),
                                    P@/e/ <- P@/e'/, P@/e/ <- P@/e''/ }
     | Col /e as Ast.Case(e',k,e'',e''')/ =
                Col /e'/ + Col /e''/ + Col /e'''/
                + { X@/e/ <- X@/e''/, X@/e/ <- X@/e'''/ }
                + { P@/e/ <- P@/e'/, P@/e/ <- P@/e''/, P@/e/ <- P@/e'''/ }
     | Col /e as Ast.Raise(e')/ = Col /e'/ + { P@e <- X@/e'/ }
     | Col /e as Ast.Mraise(e',Ks)/ =
                let
                  val K = /Ast.list2set Ks/
                in
                  Col /e'/ + { P@e <- minus(X@/e'/,/e'/, K) }
                end
     | Col /e as Ast.Praise(e', k)/ =
                Col /e'/ + { P@/e/ <- cap(X@/e'/,/e'/,/k/) }
     | Col /e as Ast.Handle(e', f as Ast.Lam(x,e''))/ =
                Col /e'/ + Col /e''/
                + { X@/e/ <- X@/e'/, X@/e/ <- app_x(/f/, P@/e'/) }
                + { X@/x/ <- P@/e'/, P@/e/ <- app_p(/f/, P@/e'/) }


   (* constraint closure rules *)

   ccr  X@a <- app_x(/e/,X@b), /Ast.Lam(x,e')/ in post Cfa.Lam@/e/
       -----------------------------------------
             X@a <- X@/e'/, X@/x/ <- X@b

    |  X@a <- app_x(/e/,P@b), /Ast.Lam(x,e')/ in post Cfa.Lam@/e/
       -----------------------------------------
            X@a <- X@/e'/, X@/x/ <- P@b

    |  P@a <- app_p(/e/,X@b), /Ast.Lam(x,e')/ in post Cfa.Lam@/e/
       -----------------------------------------
            P@a <- P@/e'/, X@/x/ <- X@b

    |  P@a <- app_p(/e/,P@b), /Ast.Lam(x,e')/ in post Cfa.Lam@/e/
       -----------------------------------------
            P@a <- P@/e'/, X@/x/ <- P@b


   (* constraint image definition *)

   cim exn(k) = {k}
     | minus(X,/e/,K) = if /Ast.exncarryexn(e)/ then X
                        else { x | x from X, not (x in K) }
     | cap(X,/e/,k) = if /Ast.exncarryexn(e)/ then X
                      else { x | x from X, x = k }
 end 
\end{verbatim}
}

\item A CTL bind:
\begin{verbatim}
query SatelliteInvariant = x: pre CP.E. (EG y: post CP.E. x <= y)
\end{verbatim}
The ``{\tt SatelliteInvariant}'' holds at a program point iff
there exists (``{\tt E}'' in ``{\tt EG}'') an execution path from the
program point such that every (``{\tt G}'' in ``{\tt EG}'') post-state
along the path is larger than or equal to the pre-state of the
starting program point. The pre-states and post-states associated with
the program points are the results (``{\tt CP.E}'') from analysis
``{\tt CP}''.
\ei

\chapter{\H{프로그램 분석의 기획}{Well-formed Specification for
Program Analysis}}
\[
\begin{array}{rrcl}
\nt{Type}&\t &::=& 
	\nt{int}\;|\;\nt{bool}\;|\;\St\;|\;\Lt
  \;|\;\t_1\times\t_2
                  %(Kdel 10/14/02
                  %\t_1+\t_2\;|\;
                  %)Kdel
  \;|\;\t_1\to\t_2\;|\;\power{\t}
  \;|\;\tynml\;|\;\kindIt{\t}{\kappa}\\
\nt{Set} &\St &::=& \intervalset
              \;|\;\{\elmtidrow\}\;|\;\power{\St} \\
	 &&|& \St_1\times\St_2\;|\;\St_1+\St_2
         \;|\;\St_1\mapsto\St_2 \\
	 &&|& \tylongidnml\\
\nt{Lattice} &\Lt &::=& 
	 \flat{\St}\;|\;\ordered{\St}\;|\;\power{\St} \\
	 &&|& \Lt_1\times\Lt_2\;|\;\Lt_1+\Lt_2
	 \;|\;\Lt_1\mapsto\Lt_2\;|\;\St\mapsto\Lt \\
         &&|& \strlongidnml\\
\nt{Kind} &\kappa&::=&\nt{index}\;|\;\nt{syntree}\;|\;\nt{integer}
     \;|\;\nt{power}\;|\;\nt{sum}\;|\;\nt{product}\;|\;\nt{arrow}
     \;|\;\cdot\\
\end{array}
\]
\[
\begin{array}{rcrcl}
  &&\nt{Pre} &=&\nt{Type}\cup\{\cdot\} \\
  &&\nt{Post} &=&\nt{Type} \\
  &&\nt{Syntree} &=&\nt{Set}\cup\{\cdot\} \\
  &&\nt{Index} &=&\nt{Set}\cup\{\cdot\} \\
\mbox{$p$ or $(\St_1,\St_2)$} &\in&
 \nt{Pivot}&=&\nt{Syntree}\times\nt{Index}\\
(\t_1,\t_2,p)&\in&\nt{EqnType}&=&\nt{Pre}\times\nt{Post}\times\nt{Pivot}\\
\VE &\in& \nt{VarEnv} &=&
          \nt{VarId}\finmap\nt{Type}\cup\nt{EqnType}\\%\cup\nt{CnstType}\\
\CE &\in&\nt{CnstEnv} &=& \nt{CvarEnv}\times\nt{ConEnv} \\
\CV &\in&\nt{CvarEnv} &=& \nt{CvarId}\finmap\nt{Set}
			\cup\nt{Set}\times\nt{Index}\\
\CN &\in&\nt{ConEnv} &=& \nt{ConId}\finmap\nt{Type} \\
\SE &\in& \nt{SetEnv} &=& \nt{SetId}\finmap\nt{Set}\cup\nt{Kind} \\
\LE &\in& \nt{LatEnv} &=& \nt{LatId}\finmap\nt{Lattice}\cup\nt{Kind} \\
\mbox{$\E$ or $(\VE,\SE,\LE,\CE)$}\;
    &\in& \nt{Env}&=&\nt{VarEnv}\times\nt{SetEnv}\times\nt{LatEnv}
		     \times\nt{CnstEnv} \\
&&&&\\
\AE &\in& \nt{AnaEnv}&=&\nt{AnaId}\finmap\nt{Env}\\
\GE &\in&\nt{SigEnv}&=&\nt{SigId}\finmap\nt{Env}\\
\TE &\in&\nt{TemEnv}&=&\nt{TemId}\finmap\nt{ParamEnv}\times\nt{Env}\\
    &   &\nt{ParamEnv}&=&\cup_{k\geq1}(\nt{AnaId}\times\nt{Env})^k\\
C &\in&\nt{Context}&=&\nt{AnaEnv}\times\nt{SigEnv}
		\times\nt{TemEnv}\times\nt{Env}
\end{array}
\]

\bi
\item[$A\finmap B$:]
  \H{집합 A의 유한한 부분집합에서 집합 B로 가는 함수들의 집합.}
    {The set of functions from finite subsets of $A$ into $B$.}

\item[{$\may{}$}:]
 \H{의미구조의 규칙에서도 $\may{}$는 문법구조에서 처럼, 덧 붙일 수
 있는 것을 표현한다. 예를들어,
  \[
  \begin{array}{c}
  \infer{C\;\may{D}}{A\;\may{B}}
  \end{array}
  \]
  는 다음의 두가지 규칙을 의미한다:
  \[
  \begin{array}{c}
  \infer{C}{A}\quad\quad
  \infer{C\;D}{A\; B}
  \end{array}
  \]
 }{Optional case.}

\item[{$a/b$}:]
 \H{``$a/b$''는 ``$a$ 혹은 $b$''를 표현한다. 여러뭉치가 사용될 때는
  앞의 것은 앞의 것 끼리, 뒤에 것은 뒤에 것끼리 있는 것을
  표현한다. 예를들어,
  \[
  \begin{array}{c}
  \infer{B\;a/b}{A\;a'/b'}
  \end{array}
  \]
  는 다음의 두가지 규칙을 의미한다:
  \[
  \begin{array}{c}
  \infer{B\;a}{A\;a'}\quad\quad
  \infer{B\;b}{A\;b'}
  \end{array}
  \]
 }{Alternative case. The correspondence is implied.}

\item[{$\dom{f}, \ran{f}$}]
 \H{``$\dom{f}$''과 ``$\ran{f}$''은 각각 함수 $f$가 정의된 집합과  $f$의 결과
    집합을 의미한다.}
   {``$\dom{f}$'' and ``$\ran{f}$''
    respectively denotes the domain and the range of $f$.}

\item[{$\coerce{g}{A}$}:]
 \H{``$\coerce{g}{A}$''는 $G$의 원소 $g$를 $A$의 원소로 만드는데, 이
  때 $A$의 원소가 가져야 하는 부품은 공집합으로 한다. 예를들어,
  $A = G\times H$이고 $H = X\finmap Y$일 때 ``$\coerce{g}{A}$''는 ``$\la
  g,\{\}\ra$''를 뜻한다.
 }{It denotes an element of a product set $A$ that is made from
$g$. For exampel, if $A = G\times H$ and $H = X\finmap Y$,
``$\coerce{g}{A}$'' denotes ``$\la  g,\{\}\ra$.''}

\item[{$f+g$}:]
 \H{``$f+\entry{x}{y}$''는 함수 $f$의 정의영역에서 $x$ 엔트리를
 $y$로 바꾸거나 ($x\in\dom{f}$인 경우) 확장한다 ($x\not\in\dom{f}$인 경우).
 일반적으로 ``$f+g$''는 함수 $g$가 함수 $f$를 바꾸거나 확장하는 것인데, 
 필요하면 $g$를 $f$의 타입 $A$로 확장시킨 후에 ($\coerce{g}{A}$)
 정의되는 것으로 한다.
 }{Overshadow $f$ by $g$. If $f$ is a tuple and $g$ is of its one
component type, other components of $f$ is intact.}

\item[$\of{A}{B}$:]
 \H{``$\of{A}{B}$'' 는 $B$가 $(\cdots,A,\cdots)$일때 $A$를 뜻한다.}
   {When $B = (\cdots,A,\cdots)$, ``$\of{A}{B}$'' denotes $A$.}

\item[$\t\setminus\t'$:]
 \H{곱(product) 타입 $\t$에서 $\t'$을 뺀 결과 타입을 뜻한다. 
    아무 타입도 남지않으면 $\cdot$을 남긴다.}
   {It denotes the type that results from removing $\t'$ component
from a product type $\t$. When nothing is left, it denotes ``empty
type'' $\cdot$.}

\item[$\t'\in\t$:]
 \H{곱(product) 타입 $\t$에서 $\t'$을 부품으로 가지고 있으면 참,
    아니면 거짓이다.}
   {True if $\t'$ is a component type of a product type $\t$, false otherwise.}

\item[$C_\beta(\alpha\nt{longid})$:]
 \[
 \begin{array}{rcl}
 C_\beta(\alpha\nt{id}) &=& (\of{\beta}{(\of{E}{C})})(\alpha\nt{id})\\
 C_\beta(\anaid.\alpha\nt{id}) &=&
  (\of{\beta}{(\of{\AE}{C})(\anaid)})(\alpha\nt{id})
 \end{array}
 \]

\item[$\nt{Kind}(\t)$:]
 \[
 \begin{array}{rclcrcl}
 \nt{Kind}(\power{\t}) &=& \nt{power} &\quad&
 \nt{Kind}(\t_1\times\t_2) &=&\nt{product} \\
 \nt{Kind}(\t_1+\t_2) &=&\nt{sum} &&
 \nt{Kind}(\t_1\mapsto\t_2) &=&\nt{arrow}\\
 \nt{Kind}(\nt{int}) &=& \nt{integer} &&
 \nt{Kind}(\kindIt{\t}{\kappa}) &=& \kappa \\
 \end{array}
 \]

%\item[{$|\t|$}:]
% \H{타입 \t에 있는 태그들을 모두 없앤다. 예를들어,
%$|\t_1\times(\t_2+\t_3,1)|=\t_1\times(\t_2+\t_3).$}{}
\ei

%\bi
%\item \H{Rabbit과 nML에서 공통된 타입은 \tl{int}와 \tl{bool} 뿐이다.}
%        {Common types both in Rabbit and nML is only \tl{bool} and \tl{int}.}
%
%%\item[{$\varid$}:] \H{}{}
%\ei

\ruleclass{프로그램 분석 정의}{Analysis Definition}{\type{C}{\topdec}{C'}}
%\rule{\type{C}{\adec}{\coerce{\E}{\nt{Context}}}}
%     {\type{C}{\adec}{\E}}
\rule{\type{C}{\anadec}{\coerce{\AE}{\nt{Context}}}}
     {\type{C}{\anadec}{\AE}}
\rule{\type{C}{\sigdec}{\coerce{\GE}{\nt{Context}}}}
     {\type{C}{\sigdec}{\GE}}
\rule{\type{C}{\temdec}{\coerce{\TE}{\nt{Context}}}}
     {\type{C}{\temdec}{\TE}}
\rule{\type{C}{\topdec_1\;\topdec_2}{C_1+C_2}}
     {\type{C}{\topdec_1}{C_1}\quad
      \type{C+C_1}{\topdec_2}{C_2}}

\ruleclass{분석기 선언}{Analysis Declaration}{\type{C}{\anadec}{\AE}}
%\rule{\type{C}{\tl{analysis}\;\anabind}{NE}}
%     {\type{C}{\anabind}{NE}}
%\ruleclass{분석기 정의}{Analysis Binding}{\type{C}{\anabind}{NE}}
%\rule{\type{C}{\anaid\;\tl{=}\;\anaexp}{\{\entry{\anaid}{\E}\}}}
%     {\type{C}{\anaexp}{\E}}
\rule{\type{C}{\tl{analysis}\;\anaid\;\tl{=}\;\anaexp}
           {\{\entry{\anaid}{\E}\}}
     }
     {\type{C}{\anaexp}{\E}}

\ruleclass{분석기 정의식}{Aanalysis Expression}{\type{C}{\anaexp}{\E}}
\rule{\type{C}{\tl{ana}\;\adec\;\tl{end}}{\E}}
     {\type{C}{\adec}{\E}}
\rule{\type{C}{\temid\;\tl{(}\;\anaexp_1,\cdots,\anaexp_n\;\tl{)}}{\E}}
     {\deduce{\forall i.\type{C}{\anaexp_i}{\E_i}\quad
              \forall i.\sigmatch{\E_i}{\E_i'}	      
             }
      {\TE(\temid) = (((\anaid_1,\E_1'),\cdots,(\anaid_n,\E_n')),\E)}
     }

\ruleclass{분석기 타입 선언}{Analysis Signature Declaration}{\type{C}{\sigdec}{\GE}}
\rule{\type{C}{\tl{signature}\;\sigid\;\tl{=}\;\sigexp}
              {\{\entry{\sigid}{\E}\}}
     }
     {\type{C}{\sigexp}{\E}}

\ruleclass{분석기 타입식}{Signatre Expression}{\type{C}{\sigexp}{\E}}
\rule{\type{C}{\tl{sig}\;\adesc\;\tl{end}}{\E}}
     {\type{C}{\adesc}{\E}}
\rule{\type{C}{\sigid}{\E}}{\GE(\sigid) = \E}

\ruleclass{분석기 타입식 내용}{Signature Expression Content}{\type{C}{\adesc}{\E}}
\rule{\type{C}{\tl{set}\;\setdesc}{\E}}{\type{C}{\setdesc}{\E}}
\rule{\type{C}{\tl{lattice}\;\latdesc}{\E}}{\type{C}{\latdesc}{\E}}
\rule{\type{C}{\tl{val}\;\varid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\varid}{\tau}\}}{\nt{Env}}}}
     {\type{C}{\ty}{\tau}}
\rule{\type{C}{\tl{eqn}\;\varid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\varid}
			    {(\t_1',\t_2,(\St_1,\St_2))}
		    \}}{\nt{Env}}
	   }
     }
     {\type{C}{\ty}{\t_1\to\t_2}\quad
      \type{C}{\mbox{air'ed kinds}(\ty)}{(\St_1,\St_2)\quad
      \t_1' = \t_1\setminus\St_1\setminus\St_2}
     }
%\rule{\label{queryspec}
%      \type{C}{\tl{query}\;\ctlid\;\tl{:}\;\varlongid\nt{row}}{\E}
%     }
%     {\forall i.C_{\VE}(\varlongid_i)\in\nt{EqnType}
%     }
\rule{
      \type{C}{\tl{query}\;\ctlid\;\tl{:}\;\ty}
	   {\coerce{\{\entry{\ctlid}{\ty}\}}{\nt{Env}}}
     }
     {\type{C}{\ty}{\t\to\nt{bool}}}
\rule{\type{C}{\adesc_1\;\adesc_2}{\E_1+\E_2}}
     {\type{C}{\adesc_1}{\E_1}\quad\type{C+\E_1}{\adesc_2}{\E_2}}
%\note{\ref{queryspec}}
%     {\H{탐색의 타입은 탐색할 결과에 대한 분석 방정식
%         이름들을 열거해야 한다.}{}
%     }

\ruleclass{집합의 종류}{Set Kind Description}{\type{C}{\setdesc}{\E}}
\rule{\type{C}{\setid}{\coerce{\{\entry{\setid}{\cdot}\}}{\nt{Env}}}}
     {}
\rule{\label{setidkind}
      \type{C}{\kindIt{\setid}{\kind}}
           {\coerce{\{\entry{\setid}{\kind}\}}{\nt{Env}}}
     }{}
%     {\kind\not\in\{\tl{index},\tl{syntree}\}}
\rule{\type{C}{\setbind\mbox{\ as $\setdesc$}}{\E}}
     {\type{C}{\setbind}{\E}}

\ruleclass{래티스의 종류}{Lattice Kind Description}{\type{C}{\latdesc}{\E}}
\rule{\type{C}{\latid}{\coerce{\{\entry{\latid}{\cdot}\}}{\nt{Env}}}}
     {}
\rule{\type{C}{\kindIt{\latid}{\kind}}
           {\coerce{\{\entry{\latid}{\kind}\}}{\nt{Env}}}}
     {\kind\not=\{\tl{syntree},\tl{index},\tl{integer}\}}
\rule{\type{C}{\latbind\mbox{\ as $\latdesc$}}{\E}}
     {\type{C}{\latbind}{\E}}

\ruleclass{분석기와 분석기 타입 매치}{Analysis Type Match}{\sigmatch{\E}{\E'}}
\rule{\sigmatch{\E}{\E'}}
     {\sigmatch{\VE}{\VE'}\quad
      \sigmatch{\SE}{\SE'}\quad
      \sigmatch{\LE}{\LE'}\quad
      \sigmatch{\CV}{\CV'}\quad
      \sigmatch{\CN}{\CN'}
     }
\rule{\sigmatch{\VE}{\VE'}}
     {\forall\varid\in\dom{\VE'}.\VE(\varid) = \VE'(\varid)}
\rule{\label{sigmatchse} \sigmatch{\SE}{\SE'}}
     {\forall\setid\in\dom{\SE'}.\sigmatch{\SE(\setid)}{\SE'(\setid)}}
\rule{\sigmatch{\LE}{\LE'}}
     {\forall\latid\in\dom{\LE'}.\sigmatch{\LE(\latid)}{\LE'(\latid)}}
\rule{\sigmatch{\CV}{\CV'}}
     {\forall\cvarid\in\dom{\CV'}.\CV(\cvarid) = \CV'(\cvarid)}
\rule{\sigmatch{\CN}{\CN'}}
     {\forall\conid\in\dom{\CN'}.\CN(\conid) = \CN'(\conid)}
%\rule{\sigmatch{\nt{constraint}}{\nt{constraint}}}{}
\rule{\sigmatch{\t}{\t}}{}
\rule{\sigmatch{\t}{\cdot}}{}
\rule{\label{sigmatchkind} \sigmatch{\t}{\nt{Kind}(\t)}}{}
%\rule{\sigmatch{\Lt}{\Lt}}{}
%\rule{\sigmatch{\Lt}{\cdot}}{}
%\rule{\sigmatch{\Lt}{\nt{Kind}(\Lt)}}{}
\note{\ref{sigmatchse},\ref{sigmatchkind}}
     {\H{집합을 선언할 때는 그 종류가 \nt{index}나 \nt{syntree}라는
     것은 밝혀질 수 없으므로, 그러한 집합 종류와는 타입매치될 수 없다.
     어느 집합이 그러한 종류인지는 그 집합을 이용한 분석방정식이
     선언될 때 밝혀진다.}
     {Putting \nt{index} nor \nt{syntree} kind in a set description is
     a non-sense. Such kinds are known only when such sets are used
     with the kind annotations in the semantic function declarations.}
     }

\ruleclass{분석기 틀 선언}{Analysis Template Declaration}
	  {\type{C}{\temdec}{\TE}}
%\rule{\type{C}{\tl{analysis}\;
%\nt{tembind}}{\TE}}
%     {\type{C}{\nt{tembind}}{\TE}}
\rule{\deduce{\{\entry{\temid}
                 {(((\anaid_1,\E_1),(\anaid_2,\E_2)), \E)}
         \}}
      {
      \type{C}{\tl{analysis}\;\temid\;
               \tl{(}\;\anaid_1\;\tl{:}\;\sigexp_1\;\tl{,}\;
		       \anaid_2\;\tl{:}\;\sigexp_2\;
               \tl{)}\;
               \tl{=}\;\anaexp
	       }{}
      }
     }
     {\deduce{\type{C+\{\entry{\anaid_1}{\E_1},\entry{\anaid_2}{\E_2}\}}
                   {\anaexp}{\E}
             }
      {\type{C}{\sigexp_1}{\E_1}\quad
       \type{C}{\sigexp_2}{\E_2}\quad
      }
     }

\ruleclass{분석내용 선언}{Analysis Content Declaration}{\type{C}{\adec}{\E}}
\rule{\type{C}{\adec_1\;\adec_2}{\E_1+\E_2}}
     {\type{C}{\adec_1}{\E_1}\quad
      \type{C+\E_1}{\adec_2}{\E_2}}
\rule{\type{C}{\domdec\mbox{\ as $\adec$}}{\E}}
     {\type{C}{\domdec}{\E}}
\rule{\type{C}{\semdec\mbox{\ as $\adec$}}{\E}}
     {\type{C}{\semdec}{\E}}
\rule{\type{C}{\querydec\mbox{\ as $\adec$}}{\coerce{\VE}{\nt{Env}}}}
     {\type{\E}{\querydec}{\VE}}
%\rule{\notype{}{\domain\;\semantics\;\may{\query}}}
%     {\type{}{\domain}{\E}\quad
%      \type{\E}{\semantics}{\VE}\quad
%      \may{\type{\E+\VE}{\query}{\VE'}}
%     }

\ruleclass{도메인 선언}{Domain Declarations}{\type{C}{\domdec}{\E}}
\rule{\type{C}{\tl{set}\;\setbind}{\E}}
     {\type{C}{\setbind}{\E}}
\rule{\type{C}{\tl{lattice}\;\latbind}{\E}}
     {\type{C}{\latbind}{\E}}
\rule{\type{C}{\widenExp{\latid}{\match}}{\{\}}}
     {\t=\LE(\latid)\quad\type{\E}{\match}{\t\to\t
%(Kwang 10/14/02
					   \;\mbox{or}\;\t\times\t\to\t}
     }
\rule{\type{C}{\narrowExp{\latid}{\match}}{\{\}}}
     {\t=\LE(\latid)\quad\type{\E}{\match}{\t\to\t
					   \;\mbox{or}\;\t\times\t\to\t}
     }
%)Kwang
%\rule{\type{C}{\domain_1\;\domain_2}{\E_1+\E_2}}
%     {\type{C}{\domain_1}{\E_1}\quad\type{C+\E_1}{\domain_2}{\E_2}}
    
\ruleclass{집합의 정의}{Set Binding}{\type{C}{\setbind}{E}}
\rule{\label{setbind}
      \type{C}{\setid\;\tl{=}\;\setexp}
	   {(\VE,\{\entry{\setid}{\St}\},\{\},\{\})}
     }
     {\type{C}{\setexp}{\St,\VE}\quad
      \setid\not\in\dom{\SE}\cup\dom{\LE}} 
\rule{\label{cnstbind}
      \type{C}{\setid\;\tl{=}\;\setexp\;\tl{constraint}\;\cnstdec}
	   {(\VE,\{\entry{\setid}{\St}\},\{\},\CE)}}
     {\deduce{
       \type{C+\VE,\St}{\cnstdec}{\CE}\quad
       \setid\not\in\dom{\SE}\cup\dom{\LE}
      }{
       \type{C}{\setexp}{\St,\VE}\quad\nt{Kind}(\St)=\nt{power}
      }
     }
\note{\ref{setbind}}
     {\H{집합의 이름은 이미 정의된 집합이나 래티스의 이름이 아니어야한다.}
        {Set id must be fresh.}}
%\note{\ref{cnstbind}}
%     {\H{제약식들 뭉치로({\tt and}로 묶인) 선언될때 변수들이 재귀적으로 사용될
%수 있도록 $X$(선언되는 제약식 변수들의 집합)이 왼쪽에도
%있게된다.}{The set $X$ of constraint variables to be declared appear
%in the left-hand-side to support recursive bindings.}}

\ruleclass{래티스의 정의}{Lattice Binding}{\type{C}{\latbind}{\E}}
\rule{\label{latbind}
      \type{C}{\latid\;\tl{=}\;\latexp}{(\VE,\{\},\{\entry{\latid}{\Lt}\},\{\})}}
     {\type{C}{\latexp}{\Lt,\VE}\quad
      \latid\not\in\dom{\SE}\cup\dom{\LE}}
\note{\ref{latbind}}
     {\H{래티스의 이름은 이미 정의된 집합이나 래티스의 이름이 아니어야한다.}
        {Lattice id must be fresh.}}

\ruleclass{집합식}{Set Expression}{\type{C}{\setexp}{\St,\VE}}

\H{주의: $\St$는 집합의 속내용이다, 집합의 이름이 아니고.}
        {Note that $\St$ is a set structure, not a set name.}

\rule{\type{C}{\tl{/}\nt{tylongid}\tl{/}}{\nt{tylongid}_{\nt{nML}},\{\}}}
     {}
\rule{\type{C}{\setlongid}{\St,\{\}}}
     {\St = C_{\SE}(\setlongid)}
\rule{\label{intervalset}
      \type{C}{\braceExp{\eO\;\tl{...}\;\eT}}{\intervalset,\{\}}}
     {\type{C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\label{elemtidrow}
      \type{C}{\braceExp{\elmtidrow}}{\{\elmtidrow\},\VE'}}
     {\deduce{
      \VE' = \{\entry{\elmtid}{\{\elmtidrow\}}\:|\:\elmtid\in\{\elmtidrow\}\}
      }{\{\elmtidrow\}\cap\dom{\VE}=\emptyset}
     }
\rule{\type{C}{\tl{power}\;\setexp}{\power{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
\rule{\type{C}{\setexp_1\;\tl{*}\;\setexp_2}{\St_1\times\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\setexp_1\;\tl{+}\;\setexp_2}{\St_1+\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\setexp_1\;\tl{->}\;\setexp_2}{\St_1\mapsto\St_2,\VE_1+\VE_2}}
     {\type{C}{\setexp_1}{\St_1,\VE_1}\quad
      \type{C+\VE_1}{\setexp_2}{\St_2,\VE_2}}
\rule{\type{C}{\parenIt{\setexp}}{\St,\VE}}
     {\type{C}{\setexp}{\St,\VE}}

\note{\ref{intervalset}}
     {\H{정수의 구간 부분집합도 정수로 한다.}
        {Integer set subsumes an integer interval.}}
\note{\ref{elemtidrow}}
     {\H{집합의 원소들로 쓰이는 이름들은 새로운 이름들이어야 한다.}
        {Set element identifiers must be fresh.}}

\ruleclass{제약식 집합}{Constraint Declaration}{\type{C,\St}{\cnstdec}{\CE}}
\rule{\label{cnstdec-a}
      \type{C,\St}
           {\tl{var = }\braceExp{\cvaridrow}\;\tl{index}\;\setexp\;\;
	    \tl{rhs = }\rhs}
           {(\CV',\CN)}
     }
     {\deduce{\dom{\CV}\cap\{\cvaridrow\}=\{\}\quad
	      \type{C+\CV',\St}{\rhs}{\CN}
      }
      {\type{C}{\setexp}{\St',\{\}}\quad
       \CV'\leteq\{\forall i.\entry{\cvarid_i}{(\St,\St')}\}
      }
     }
\rule{\label{cnstdec-b}
      \type{C,\St}
           {\tl{var = }\braceExp{\cvaridrow}\;\;
	    \tl{rhs = }\rhs}
           {(\CV',\CN)}
     }
     {\CV'\leteq\{\forall i.\entry{\cvarid_i}{\St}\}\quad
      \dom{\CV}\cap\{\cvaridrow\}=\{\}\quad
      \type{C+\CV',\St}{\rhs}{\CN}
     }
%\rule{\deduce{
%       (\{\entry{\cvarid}{\St}\},\CN)\;\may{+ \CE'},
%       \{\cvarid\}\;\may{\cup\; X'}
%      }{
%        \type{C,\St,X}
%             {\cvarid\;\tl{<-}\;\rhs \;\may{\tl{and}\;\cnstdec}}
%             {}
%      }
%     }
%     {\cvarid\in X\quad
%      \type{C,\St,X}{\rhs}{\CN}\quad
%      \may{\type{C,\St,X}{\cnstdec}{\CE',X'}}
%     }
\note{\ref{cnstdec-a},\ref{cnstdec-b}}
     {\H{제약식 변수들($\cvaridrow$)은 모두 달라야 한다.}{All
     constraint variables must be distinct.}}

\ruleclass{제약식의 오른팔 선언}{Constraint's RHS Declaration}
	  {\type{C,\St}{\rhs}{\CN}}
%\rule{\type{C,\St}
%	   {\tl{var}\;\may{\setid}\;\may{\tl{|}\;\rhs}}
%	   {\{\}}
%     }
%     {\may{\SE(\setid) = \St}}
\rule{\type{C,\St}
	   {\tl{var}\;\may{\setlongid}}
	   {\{\}}
     }
     {\may{\SE(\setlongid) = \St}}
%\rule{\label{rhsa}
%      \type{C,\St}
%           {\conid\;\may{\tl{:}\;\tl{atomic}}\;\may{\tl{|}\;\rhs}}
%           {\{\entry{\conid}{\St}\}\;\may{+ \CN}}
%     }
%     {\conid\not\in\dom{\CN}\quad\may{\type{C,\St}{\rhs}{\CN}}}
%\rule{\label{rhsb}
%      \type{C,\St}
%           {\conid\;\carg\;\may{\tl{:}\;\tl{atomic}}\;\may{\tl{|}\;\rhs}}
%           {\{\entry{\conid}{\t_1\to\St}\}\;\may{+ \CN}}
%     }
%     {\conid\not\in\dom{\CN}\quad
%      \type{C,\St}{\carg}{\t_1}\quad
%      \may{\type{C,\St}{\rhs}{\CN}}
%     }
\rule{\label{rhsa}
      \type{C,\St}
           {\conid\;\may{\tl{:}\;\tl{atomic}}}
           {\{\entry{\conid}{\St}\}}
     }
     {}
\rule{\label{rhsb}
      \type{C,\St}
           {\conid\;\carg\;\may{\tl{:}\;\tl{atomic}}}
           {\{\entry{\conid}{\t_1\to\St}\}}
     }
     {
      \type{C,\St}{\carg}{\t_1}
     }
\rule{\label{rhsrow}
      \type{C,\St}
           {\rhs_1\;\tl{|}\;\rhs_2}
           {\CN_1+\CN_2}
     }
     {\type{C,\St}{\rhs_1}{\CN_1}\quad
      \type{C,\St}{\rhs_2}{\CN_2}\quad
      \dom{\CN_1}\cap\dom{\CN_2}=\emptyset
     }
%\rule{\notype{C,\St}{\tl{var}}}{}
%\rule{\notype{C,\St}{\tl{var}\;\setid}}
%     {\SE(\setid) = \St}

\note{\ref{rhsrow}}
     {\H{제약식에 사용되는 함수심볼들은 모두 달라야 한다.}
        {Function symbols in constraint's rhs declarations must all be
	  distinct.}
     }

\ruleclass{제약식 함수심볼의 변수들}{}{\type{C,\St}{\carg}{\t}}
\rule{\type{C,\St}{\tl{var}}{\St}}{}
\rule{\type{C,\St}{\tl{var}\;\setlongid}{\St'}}
     {\SE(\setlongid) = \St'}
\rule{\label{setexpincnstdec}
      \type{C,\St}{\setexp\ as\ \carg}{\St'}}
     {\type{C}{\setexp}{\St',\{\}}}
\rule{\label{setexpincnstdec2}
      \type{C,\St}{\tl{(}\;\carg_1\tl{,}\;\carg_2\;\tl{)}}
           {\St_1\times\St_2}
     }
     {\type{C,\St}{\carg_1}{\St_1}\quad\type{C}{\carg_2}{\St_2}}

\note{\ref{setexpincnstdec}}
     {\H{제약식 함수심볼의 선언에 쓰는 집합식은 새로운 환경($\VE$)을
      만들어내지 않아야 한다. (for convenience, not must)}
     {For convenience, no non-empty $\VE$ is constructed from the set
     expressions used in declaring function symbol's argument types.}
     }

%\ruleclass{제약식 변수}{Constraint Variable}{\notype{C,X}{\cvar}}
%\rule{\notype{C,X}{\cvarid\;\may{\tl{index}\;\setexp}}}
%     {\cvarid\in X\quad
%      \may{\setexp\mbox{\ is not a compound set}\quad
%	   \type{C}{\setexp}{s}\quad
%           \CE(\cvarid) = s
%          }
%     }
%\rule{\notype{C,X}{\indexExp{\cvarid}{e}}}
%     {\CE(\cvarid) = (\setid, s)\quad
%      \type{C}{e}{s}}

\ruleclass{래티스 식}{Lattice Expression}{\type{C}{\latexp}{\Lt,\VE}}

\H{주의: $\Lt$는 래티스의 속내용이다, 래티스의 이름이 아니고.}
        {Note that $\Lt$ is a lattice structure, not a lattice name.}

\rule{\type{C}{\tl{/}\strlongid\tl{/}}{\strlongidnml,\{\}}}
     {}
\rule{\type{C}{\latid}{\Lt,\{\}}}
     {\Lt = C_{\LE}(\latlongid)}
\rule{\type{C}{\tl{flat}\;\setexp}{\flat{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
\rule{\type{C}{\tl{power}\;\setexp}{\power{\St},\VE}}
     {\type{C}{\setexp}{\St,\VE}}
%(Kwang 10/14/02
\rule{\label{orderedset}
      \type{C}{\setexp\;\tl{with join}/\tl{meet}\;\match_1
               \may{\tl{meet}/\tl{join}\;\match_2}}
              {\ordered{\St},\VE}
     }
     {
      \deduce{
       \may{\type{C}{\match_2}{\St\times\St\to\St}}\quad
       \nt{isLattice}(\St,\match_1\may{,\match_2})
       }
       {\type{C}{\setexp}{\St,\VE}\quad
        \type{C}{\match_1}{\St\times\St\to\St}
       }
     }
%)Kwang
\rule{\type{C}{\latexp_1\;\tl{*}\;\latexp_2}{\Lt_1\times\Lt_2,\VE_1+\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\latexp_1\;\tl{+}\;\latexp_2}{\Lt_1+\Lt_2,\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\latexp_1\;\tl{->}\;\latexp_2}{\Lt_1\mapsto\Lt_2,\VE_2}}
     {\type{C}{\latexp_1}{\Lt_1,\VE_1}\quad
      \type{C+\VE_1}{\latexp_2}{\Lt_2,\VE_2}}
\rule{\type{C}{\setexp\;\tl{->}\;\latexp}{\St\mapsto\Lt,\VE_2}}
     {\type{C}{\setexp}{\St,\VE_1}\quad
      \type{C+\VE_1}{\latexp}{\Lt,\VE_2}}
\rule{\type{C}{\parenIt{\latexp}}{\Lt,\VE}}
     {\type{C}{\latexp}{\Lt,\VE}}

\note{\ref{orderedset}}
     {\H{$\nt{isLattice}(\St,\match\may{,\match})$는 사용자가 정의한 join/meet
         연산($\match$)이 래티스 조건을 만족하는 지 확인한다.}
        {$\nt{isLattice}(\St,\match\may{,\match})$ checks if the user-defined join($\match$) 
         satisfies the condition for being a lattice.}
     }

%\ruleclass{래티스 원소들의 순서}{Partial Order}{\type{C}{\order}{\St}}
%\rule{\type{C}{\po\;\pat}{\St}}
%     {\type{C}{\pat}{\VE,\St\times\cdots\times\St}}
%\rule{\type{C}{\order_1\:\tl{|}\:\order_2}{\St}}
%     {\type{C}{\order_i}{\St,\VE}\quad i=1,2}
\addtocounter{equation}{2}

\ruleclass{분석 식}{Analysis Expression}{\type{C}{\e}{\t}}
\rule{\type{\C}{\tl{/}\nexp\tl{/}}{\tynml}}
     {}
\rule{\label{uid-exp}
      \type{\C}{\setlongid}{\power{\St}}}
     {\St=\C_{\SE}(\setlongid)}
\rule{\label{lid-exp}\type{\C}{\varlongid}{\t}}
     {\t=\C_{\VE}(\varlongid)} 
\rule{\type{\C}{\cvarlongid\;\tl{@}\;\pat\;\tl{<-}\;\rhsexp}{\St}}
     {
       \C_\CV(\cvarlongid) = (\St,\St')\quad
       \type{\C,\St}{\rhsexp}{\char`\_}\quad
       \type{\C}{\pat}{\char`\_,\St'}
     }
\rule{\type{\C}{\cvarlongid\;\tl{<-}\;\rhsexp}{\St}}
     {
       \C_\CV(\cvarlongid) = \St\quad
       \type{\C,\St}{\rhsexp}{\char`\_}
     }
\rule{\type{\C}{\integer}{\nt{int}}}
     {}
\rule{\type{\C}{(\tl{top}|\tl{bottom}|\tl{\char`\^}|\tl{\char`\_\char`\_})}{\Lt}}
     {}
%\rule{\type{\C}{\varid}{\t}}
%     {\t=\VE(\varid)}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*}|\tl{-})\;\eT}{\nt{int}}}
     {\type{\C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*})\;\eT}{\Lt}}
     {\type{\C}{\e_i}{\Lt}\quad i=1,2}
\rule{\type{\C}{\eO\;(\tl{+}|\tl{*}|\tl{-})\;\eT}{\power{\t}}}
     {\type{\C}{\e_i}{\power{\t}}\quad i=1,2}
\rule{\type{\C}{\eO\;\rop\;\eT}{\nt{bool}}}
     {\type{\C}{\e_i}{\t}\quad i=1,2\qquad\ropTy{\t}}

\rule{\type{\C}{\braceExp{\eO\;\tl{...}\;\eT}}{\power{\nt{int}}}}
     {\type{\C}{\e_i}{\nt{int}}\quad i=1,2}
\rule{\label{collection-exp}
      \type{\C}{\braceExp{\erow}}{\power{\t}}}
     {\forall\e\in\{\erow\}.\type{\C}{\e}{\t}}
\rule{\type{\C}{\setcomExp{\erow}{\qual}}{\power{\t}}}
     {\type{\C}{\qual}{\VE}\quad
      \forall\e\in\{\erow\}.\type{\C+\VE}{\e}{\t}}
\rule{\label{mrule-collection-exp}
      \type{\C}{\braceExp{\mrulerow}}{\t_1\mapsto\t_2}}
     {\forall\mrule\in\{\mrulerow\}.\type{\C}{\mrule}{\t_1\to\t_2}\quad
%(Kmod 10/14/02
       \t_1\mapsto\t_2\in\ran{\C_\SE}\cup\ran{\C_\LE}
     }
%)Kmod
\rule{\label{mrule-qual-collection-exp}
      \type{\C}{\setcomExp{\mrulerow}{\qual}}{\t_1\mapsto\t_2}}
     {\deduce{
       \forall\mrule\in\{\mrulerow\}.\type{\C+\VE}{\mrule}{\t_1\to\t_2}
      }{\type{\C}{\qual}{\VE}\quad
%(Kmod 10/14/02
        \t_1\mapsto\t_2\in\ran{\C_\SE}\cup\ran{\C_\LE}
%)Kmod
      }
     }
%(Ymod 11/01/02
\rule{\type{\C}{\foldExp{(\tl{+}|\tl{*})}{\e}}{\nt{int}/\Lt/\power{\t}}}
     {\type{\C}{\e}{\power{\nt{int}}/\power{\Lt}/\power{\power{\t}}}}
%)Ymod
\rule{\type{\C}{\tupleExp{\e_1}{\e_2}}{\t_1\times\t_2}}
     {\type{\C}{\e_i}{\t_i}\quad i=1,2}
\rule{\type{\C}{\projExp{\e}{\tl{1}}}{\t_1}}
     {\type{\C}{\e}{\t_1\times\t_2}}
\rule{\type{\C}{\projExp{\e}{\tl{2}}}{\t_2}}
     {\type{\C}{\e}{\t_1\times\t_2}}
%(Kdel 10/14/02
%\rule{\type{\C}{\injExp{\e}{\ty}{\tl{1}}}{\t_1+\t_2}}
%     {\type{\C}{\e}{\t_1}\quad
%      \type{\C}{\ty}{\t_1+\t_2}}
%\rule{\type{\C}{\injExp{\e}{\ty}{\tl{2}}}{\t_1+\t_2}}
%     {\type{\C}{\e}{\t_2}\quad
%      \type{\C}{\ty}{\t_1+\t_2}}
%)Kdel
\rule{\type{\C}{\letExp{\valdec}{\e}}{\t}}
     {\type{\C}{\valdec}{\VE}\quad
      \type{\C+\VE}{\e}{\t}}
\rule{\type{\C}{\fnExp{\match}}{\t_1\to\t_2}}
     {\type{\C}{\match}{\t_1\to\t_2}}
\rule{\type{\C}{\appExp{\eO}{\eT}}{\t_2}}
     {\type{\C}{\eO}{\t_1\to\t_2\;\mbox{or}\;\t_1\mapsto\t_2}\quad
      \type{\C}{\eT}{\t_1}}
\rule{\type{\C}{\parenExp{\e}}{\t}}
     {\type{\C}{\e}{\t}}
\rule{\type{\C}{\coerceExp{\e}{\ty}}{\t}}
     {\type{\C}{\e}{\t}\quad\type{\C}{\ty}{\t}}
%(Kdel 10/17/02
%\rule{\label{casting1inexp}\type{\C}{\coerceExp{\e}{\ty}}{\t}}
%     {\type{\C}{\e}{\t'}\quad\type{\C}{\ty}{\t}\quad\t=\cdots+\t'+\cdots}
%\rule{\label{casting2inexp}\type{\C}{\coerceExp{\e}{\ty}}{\t}}
%     {\type{\C}{\e}{\t'}\quad\type{\C}{\ty}{\t}\quad\t'=\cdots+\t+\cdots}
%)Kdel
\rule{\type{\C}{\indexExp{\may{\tl{pre}}\;\varlongid}{e}}{\t_1}} 
     {C_{\VE}(\varlongid) = (\t_1,\t_2,(s_1,s_2))\quad
      \type{C}{e}{s_2}}
\rule{\type{\C}{\indexExp{\may{\tl{post}}\;\varlongid}{e}}{\t_2}}
     {C_{\VE}(\varlongid) = (\t_1,\t_2,(s_1,s_2))\quad
      \type{C}{e}{s_2}}
%(Kadd 10/17/02
\rule{\label{expcast1}\type{\C}{e}{\t}}
     {\type{\C}{e}{\t'}\quad
      \t\in\ran{\C_\SE}\cup\ran{\C_\LE}\quad
      \t=\cdots+\t'+\cdots
     }
%\rule{\label{expcast2}\type{\C}{e}{\t'}}
%     {\type{\C}{e}{\t}\quad
%      \t\in\ran{\C_\SE}\cup\ran{\C_\LE}\quad
%      \t=\cdots+\t'+\cdots
%     }
\rule{\label{expcast3}\type{\C}{e}{\flat{\St}}}
     {\type{\C}{e}{\St}\quad\flat{\St}\in\ran{\C_\LE}}
%\rule{\label{expcast4}\type{\C}{e}{\St}}
%     {\type{\C}{e}{\flat{\St}}}
%)Kadd

%\rule{\type{\E}{\e}{\t'}}
%     {\type{\E}{\e}{\t}\quad\cast{\E}{\t}{\t'}}
%
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\nt{int}}}
%     {\type{\E}{\e}{\t}\quad\SE(\domid)=\intervalset}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1}}
%     {\type{\E}{\e}{\St_1+\St_2}\quad\SE(\domid)=\St_1}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1+\St_2}}
%     {\type{\E}{\e}{\St_1}\quad\SE(\domid)=\St_1+\St_2}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\flat{\St}}}
%     {\type{\E}{\e}{\St}\quad\SE(\domid)=\flat{\St}}
%\rule{\type{\E}{\coerceExp{\e}{\domid}}{\St_1}}
%     {\type{\E}{\e}{\St_1+\St_2}\quad\SE(\domid)=\St_1}

\note{\ref{uid-exp}}
     {\H{분석식에서 \uid는 정의된 집합의 이름이어야 한다.}{\uid\ in
     semantic expression must be a set id.}}
\note{\ref{lid-exp}}
     {\H{분석식에서 \lid는 집합의 원소이름(\elmtid)이거나 정의된
     변수(\varid) 이름이어야 한다.} 
        {\lid\ in semantic expression must be either a set element id or a variable id.}}
\note{\ref{collection-exp}}
     {\H{집합의 원소나 래티스의 원소를 모아놓을 수 있다.}{Collections
     of set elements or lattice elements.}}
\note{\ref{mrule-collection-exp},\ref{mrule-qual-collection-exp}}
%(Kmod 10/14/02
     {\H{함수테이블은 사용자가 정의한 집합이나 래티스의 원소들이어야 한다.
         ($\t_1\mapsto\t_2\in\ran{\C_\SE}\cup\ran{\C_\LE}$).}
        {A map is legal only when it is an element of a 
         user-defined set or lattice.}}
%)Kmod
%(Kadd 10/17/02
\note{\ref{expcast1},\ref{expcast3}}%,\ref{expcast4}}
     {\H{최소로 필요한 타입변환이 언제 어떻게 필요한 지는 타입검증
         알고리즘이 알아내야 한다.}
        {Type checking algorithm has to find the optimal number of
         places for applying these structural casting rules.}
     }
%)Kadd

\ruleclass{관계연산 가능한 타입}{Type with Relational Operations}{\ropTy{\t}}
%\rule{\ropTy{\nt{int}}}{}
%\rule{\ropTy{\nt{bool}}{}
%\rule{\ropTy{\t}}{\t\;\mbox{as}\;\Lt\quad\ropTy{\Lt}}
%\rule{\ropTy{\t}}{\t\;\mbox{as}\;\St\quad\ropTy{\St}}
%\rule{\ropTy{\t_1\times\t_2}}{\ropTy{\t_1}\quad\ropTy{\t_2}}
%\rule{\ropTy{\t_1+\t_2}}{\ropTy{\t_1}\quad\ropTy{\t_2}}
%\rule{\ropTy{\power{\t}}}{\ropTy{\t}}
%\rule{\ropTy{\kindIt{\t}{\kappa}}}{\ropTy{\t}}
\rule{\ropTy{\t}}
     {\mbox{$\t$ has neither $\t_1\to\t_2$ nor nML type as its component.}}
%\rule{\ropTy{\St}}{\mbox{$\St$ has no nML type as its component}}
%\rule{\ropTy{\Lt}}{\mbox{$\Lt$ has no nML type as its component}}

\ruleclass{타입 식}{Type Expression}{\type{C}{\ty}{\t}}
\rule{\type{C}{\tl{int}}{\nt{int}}}
     {}
\rule{\type{C}{\tl{/}\tylongid\tl{/}}{\tylongidnml}}
     {}
\rule{\type{C}{\domlongid}{\t}}
     {\t = (\SE+\LE)(\domlongid)}
\rule{\type{C}{\tl{power}\;\ty}{\power{\t}}}
     {\type{C}{\ty}{\t}}
\rule{\label{fnty}
      \type{C}{\ty_1\;\tl{->}\;\ty_2}{\t_1\to\t_2}}
     {\type{C}{\ty_i}{\t_i}\quad i=1,2}
\rule{\type{C}{\ty_1\;\tl{*}\;\ty_2}{\t_1\times\t_2}}
     {\type{C}{\ty_i}{\t_i}\quad i=1,2}
\rule{\label{sumtypemustbedefined}
      \type{C}{\ty_1\;\tl{+}\;\ty_2}{\t_1+\t_2}}
%(Kmod 10/14/02
     {\type{C}{\ty_i}{\t_i}\quad i=1,2\quad
      \quad\t_1+\t_2\in\ran{\C_\SE}\cup\ran{\C_\LE}
     }
%)Kmod
%(Kadd 10/19/02
\rule{\label{flattypemustbedefined}
      \type{C}{\tl{flat}\;{\ty}}{\flat{\t}}}
     {\type{C}{\ty}{\t}\quad
      \flat{\t}\in\ran{\C_\LE}
     }
%)Kadd
\rule{\type{C}{\parenIt{\ty}}{\t}}
     {\type{C}{\ty}{\t}}
\rule{\type{C}{\kindIt{\ty}{\kind}}{\kindIt{\t}{\kind}}}
     {\type{C}{\ty}{\t}}
\rule{\type{C}{\kindIt{\ty}{\tl{index}}}{\kindIt{\St}{\nt{index}}}}
     {\type{C}{\ty}{\St}\quad
      \mbox{air $\kindIt{\St}{\nt{index}}$}}
\rule{\type{C}{\kindIt{\ty}{\tl{syntree}}}{\kindIt{\St}{\nt{syntree}}}}
     {\type{C}{\ty}{\St}\quad
      \mbox{air $\kindIt{\St}{\nt{syntree}}$}}
\note{\ref{fnty}}
     {\H{함수 타입식은 함수집합/래티스($\t_1\mapsto\t_2$)가 아니고
         함수 계산식의 타입($\t_1\to\t_2$)을 이른다.}
	{Function type denotes semantic functions, not the function
         lattices or sets.} 
     }
\note{\ref{sumtypemustbedefined},\ref{flattypemustbedefined}}
     {\H{합 타입은 집합이나 래티스로 정의되어 있어야 한다. Flat
         래티스 타입은 래티스로 정의되어 있어야 한다.(번역의
         편리를 위해서.)}
        {Sum type should be defined as a domain (set or
         lattice).}
     }

\ruleclass{바람에 실려온 힌트}{Aired Kind Hints}
	  {\type{C}{\mbox{air'ed kinds}(\star)}{(\St_1,\St_2)}}

\mbox{$\star$ is either \e\ or\ \ty.}
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\St_1,\St_2)}}
     {\kindIt{\St_1}{\nt{syntree}}\;\;
      \kindIt{\St_2}{\nt{index}}
      \mbox{\ are air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\St,\St)}}
     {\mbox{only\ }\kindIt{\St}{\nt{syntree}}
      \mbox{\ is air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\cdot,\St)}}
     {\mbox{only\ }\kindIt{\St}{\nt{index}}
      \mbox{\ is air'ed from $\star$}
     }
\rule{\type{C}{\mbox{air'ed kinds}(\star)}{(\cdot,\cdot)}}
     {\mbox{nothing is air'ed from $\star$}
     }

%\rule{\type{\E}{\parenExp{\ty\;\tl{,}\;\tl{1}}}{(\t,1)}}
%     {\type{\E}{\ty}{\t}}
%\rule{\type{\E}{\parenExp{\ty\;\tl{,}\;\tl{2}}}{(\t,2)}}
%     {\type{\E}{\ty}{\t}}
%
%\ruleclass{타입 적응}{Type Cast}{\cast{\E}{\t}{\t'}}
%\rule{\cast{\E}{\t}{\t}}{}
%\rule{\label{cast-into-sum}
%      \cast{\E}{\t_{1/2}}{(\t_1+\t_2,{1/2})}}
%     {\exists 1\:\domid:\t_1+\t_2 = (\SE+\LE)(\domid)}
%\rule{\cast{\E}{(\t_1+\t_2,1/2)}{\t_{1/2}}}{}
%\rule{\label{cast-into-clean}
%      \cast{\E}{(\t_1+\t_2,1/2)}{\t_1+\t_2}}{}
%
%\note{\ref{cast-into-sum}}
%     {\H{타입($\t_i$)이 덧셈타입($\t_1+\t_2$)으로 적응할 수 있으려면 그 
%       타입($\t_1+\t_2$)은 집합이나 래티스로 사용자가 선언해 놓은
%       것이어야 한다. 이때, 그러한 집합이나 래티스로 정의된 이름은
%       유일해야 한다.}{}}
%\note{\ref{cast-into-clean}}
%     {\H{태그가 붙은 덧셈타입$(\t_1+\t_2, t)$은 태그가 없는 
%         타입($\t_1+\t_2$)으로 적응할 수 있다.}{}}
%
\ruleclass{패턴 매치}{Pattern Match}{\type{C}{\match}{\t_1\to\t_2}}
\rule{\type{C}{\mrule\;\may{\tl{|}\;\match}}{\t_1\to\t_2}}
     {\type{C}{\mrule}{\t_1\to\t_2}\quad
      \may{\type{C}{\match}{\t_1\to\t_2}}}

\ruleclass{매치 룰}{Match Rule}{\type{C}{\mrule}{\t_1\to\t_2}}
\rule{\type{C}{\pat\;\tl{=>}\;e}{\t_1\to\t_2}}
     {\type{C}{\pat}{\VE,\t_1}\quad\type{C+\VE}{e}{\t_2}}

\ruleclass{패턴}{Pattern}{\type{C}{\pat}{\VE,\t}}
\rule{\type{C}{\tl{/}\npat\tl{/}}{\{\},\tylongid_{\nt{nML}}}}
     {}
\rule{\type{C}{\tl{\char`\_}}{\{\},\t}}{}
\rule{\type{C}{\varid}{\{\entry{\varid}{\t}\},\t}}{}
\rule{\type{C}{\braceExp{\patrow\;\may{\tl{...}}}}{\VE,\power{\t}}}
     {\type{C}{\patrow}{\VE,\t}}
\rule{\type{C}{\braceExp{\pat_1\;\tl{...}\;\pat_2}}
           {\VE_1+\VE_2,\power{\nt{int}}}}
     {\type{C}{\pat_1}{\VE_1,\nt{int}}\quad
      \type{C}{\pat_2}{\VE_2,\nt{int}}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}
\rule{\type{C}{\braceExp{\mpatrow\;\may{\tl{...}}}}{\VE,\t_1\mapsto\t_2}}
     {\type{C}{\mpatrow}{\VE,\t_1\mapsto\t_2}}
%(Kdel 10/14/02
%\rule{\type{C}{\injExp{\pat}{\ty}{\tl{1}}}{\VE,\t_1+\t_2}}
%     {\type{C}{\pat}{\VE,\t_1}\quad
%      \type{C}{\ty}{\t_1+\t_2}}
%\rule{\type{C}{\injExp{\pat}{\ty}{\tl{2}}}{\VE,\t_1+\t_2}}
%     {\type{C}{\pat}{\VE,\t_2}\quad
%      \type{C}{\ty}{\t_1+\t_2}}
%)Kdel
\rule{\type{C}{\tupleExp{\pat_1}{\pat_2}}{\VE_1+\VE_2,\t_1\times\t_2}}
     {\type{C}{\pat_1}{\VE_1,\t_1}\quad\type{C}{\pat_2}{\VE_2,\t_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}
\rule{\type{C}{\guardPat{\pat}{\guard}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}\quad\notype{C+\VE}{\guard}}
\rule{\type{C}{\orPat{\pat_1}{\pat_2}}{\VE,\t}}
     {\type{C}{\pat_1}{\VE,\t}\quad\type{C}{\pat_2}{\VE,\t}}
\rule{\type{C}{\asPat{\varid}{\pat}}{\VE+\{\varid\mapsto\t\},\t}}
     {\type{C}{\pat}{\VE,\t}}
\rule{\type{C}{\coerceExp{\pat}{\ty}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}\quad\type{C}{\ty}{\t}}
%(Kdel 10/17/02
%\rule{\label{casting1inpat}\type{C}{\coerceExp{\pat}{\ty}}{\VE,\t}}
%     {\type{C}{\pat}{\VE,\t'}\quad\type{C}{\ty}{\t}\quad\t=\cdots+\t'+\cdots}
%\rule{\label{casting2inpat}\type{C}{\coerceExp{\pat}{\ty}}{\VE,\t}}
%     {\type{C}{\pat}{\VE,\t'}\quad\type{C}{\ty}{\t}\quad\t'=\cdots+\t+\cdots}
%)Kdel
\rule{\type{C}{\parenIt{\pat}}{\VE,\t}}
     {\type{C}{\pat}{\VE,\t}}
%\rule{\type{\E}{\pat}{\VE,\t'}}
%     {\type{\E}{\pat}{\VE,\t}\quad\cast{\E}{\t}{\t'}}

%(Kadd 10/17/02
\rule{\label{patcast1}\type{\C}{\pat}{\VE,\t}}
     {\type{\C}{\pat}{\VE,\t'}\quad
      \t\in\ran{\C_\SE}\cup\ran{\C_\LE}\quad
      \t=\cdots+\t'+\cdots
     }
%\rule{\label{patcast2}\type{\C}{\pat}{\VE,\t'}}
%     {\type{\C}{\pat}{\VE,\t}\quad
%      \t\in\ran{\C_\SE}\cup\ran{\C_\LE}\quad
%      \t=\cdots+\t'+\cdots
%     }
\rule{\label{patcast3}\type{\C}{\pat}{\VE,\flat{\St}}}
     {\type{\C}{\pat}{\VE,\St}\quad\flat{\St}\in\ran{\C_\LE}}
%\rule{\label{patcast4}\type{\C}{\pat}{\VE,\St}}
%     {\type{\C}{\pat}{\VE,\flat{\St}}}
%
\note{\ref{patcast1},\ref{patcast3}}%,\ref{patcast4}}%,\ref{patcast4}}
     {\H{패턴의 타입 변환은 원래의 $\VE$를 변화시키지 않는다. 
         최소로 필요한 타입변환이 언제 어떻게 필요한 지는 타입검증
         알고리즘이 알아내야 한다.}
        {Pattern's type casting does not change the original $\VE$.
         Type checking algorithm has to find the optimal number of
         places for applying these structural casting rules.}}
%)Kadd

\ruleclass{패턴들}{Patttern Row}{\type{C}{\patrow}{\VE,\t}}
\rule{\type{C}{\pat\;\tl{,}\;\patrow}{\VE+\VE',\t}}
     {\type{C}{\pat}{\VE,\t}\quad
      \type{C}{\patrow}{\VE',\t}\quad
      \dom{\VE}\cap\dom{\VE'}=\emptyset}

\ruleclass{함수 패턴}{Match-Rule Pattern}{\type{C}{\mpat}{\VE,\t}}
\rule{\type{C}{\pat_1\;\tl{=>}\;\pat_2}{\VE_1+\VE_2,\t_1\mapsto\t_2}}
     {\type{C}{\pat_1}{\VE_1,\t_1}\quad
      \type{C}{\pat_2}{\VE_2,\t_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}

\ruleclass{함수 패턴들}{Match-Rule Pattern Row}{\type{C}{\mpatrow}{\VE,\t}}
\rule{\type{C}{\mpat\;\tl{,}\;\mpatrow}{\VE+\VE',\t}}
     {\type{C}{\mpat}{\VE,\t}\quad
      \type{C}{\mpatrow}{\VE',\t}\quad
      \dom{\VE}\cap\dom{\VE'}=\emptyset}

\ruleclass{집합 원소의 자격}{Qualification}{\type{C}{\qual}{\VE}}
\rule{\type{C}{\gen\may{\;\tl{,}\;\guard}}{\VE}}
     {\type{C}{\gen}{\VE}\quad\may{\notype{C+\VE}{\guard}}}

\ruleclass{집합 원소의 소속}{Generation}{\type{C}{\gen}{\VE}}
\rule{\type{C}{\pat\;\tl{from}\;\e}{\VE}}
     {\type{C}{\pat}{\VE,\t}\quad\type{C}{\e}{\power{\t}}}
\rule{\type{C}{\mpat\;\tl{from}\;\e}{\VE}}
     {\type{C}{\mpat}{\VE,\t_1\mapsto\t_2}\quad
      \type{C}{\e}{\t_1\mapsto\t_2}}
\rule{\type{C}{\gen_1\;\tl{,}\;\gen_2}{\VE_1+\VE_2}}
     {\type{C}{\gen_1}{\VE_1}\quad
      \type{C}{\gen_2}{\VE_2}\quad
      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}

\ruleclass{집합 원소의 제한}{Guard}{\notype{C}{\guard}}
\rule{\label{firstorder}
      \notype{C}{\eO\;\rop\;\eT}}
     {\type{C}{\e_i}{\t}\quad i=1,2\quad\ropTy{\t}}
\rule{\notype{C}{\eO\;\tl{in}\;\eT}}
     {\type{C}{\eO}{\t}\quad\type{C}{\eT}{\power{\t}}}
\rule{\notype{C}{\tl{not}\;\guard}}
     {\notype{C}{\guard}}
\rule{\notype{C}{\guard_1\;(\tl{and}|\tl{or})\;\guard_2}}
     {\notype{C}{\guard_1}\quad\notype{C}{\guard_2}}
\rule{\notype{C}{\forallGuard{\gen}{\guard}}}
     {\type{C}{\gen}{\VE}\quad\notype{C+\VE}{\guard}}
\rule{\notype{C}{\forsomeGuard{\gen}{\guard}}}
     {\type{C}{\gen}{\VE}\quad\notype{C+\VE}{\guard}}
\rule{\notype{C}{\parenIt{\guard}}}
     {\notype{C}{\guard}}
\note{\ref{firstorder}}
     {\H{$\ropTy{\t}$는 타입 $\t$가 계산함수타입
         (함수집합/함수래티스가 아닌)을 포함하고 있지 않고, nML 타입이
         아니어야한다.}
        {}
}

\ruleclass{분석기 선언}{Semantics Declarations}{\type{\C}{\semdec}{\E}}
\rule{\type{C}{\valdec}{\coerce{\VE}{\nt{Env}}}}
     {\type{C}{\valdec}{\VE}}
\rule{\type{C}{\eqndec}{\coerce{\VE}{\nt{Env}}}}
     {\type{C}{\eqndec}{\VE}}
\rule{\type{C}{\ccrdec}{\{\}}}
     {\notype{C}{\ccrdec}}
%      \may{\type{\E}{\semantics}{\VE'}}}
%%      \dom{\VE}\cap\dom{\VE'}=\emptyset}}

\ruleclass{분석값 선언}{Auxiliary Value Declaration}{\type{\C}{\valdec}{\VE}}
\rule{\type{\C}{\tl{val}\;\vbind}{\VE}}
     {\type{\C}{\vbind}{\VE}}
\rule{\type{\C}{\tl{val rec}\;\vbind}{\VE}}
     {\type{\C+\VE}{\vbind}{\VE}}

\ruleclass{분석값 정의}{Auxiliary Value Binding}{\type{\C}{\vbind}{\VE}}
\rule{\type{\C}{\pat\;\tl{=}\;\e\;\may{\tl{and}\;\vbind}}{\VE\;\may{+\VE'}}}
     {\type{\C}{\pat}{\VE,\t}\quad
      \type{\C}{\e}{\t}\quad
      \may{\type{\C}{\vbind}{\VE'}\quad\dom{\VE}\cap\dom{\VE'}=\emptyset}
     }

\ruleclass{분석 방정식 선언}{Semantic Equation Declaration}
          {\type{\C}{\eqndec}{\VE}}
\rule{\type{\C}{\tl{eqn}\;\ebind}{\VE}}
     {\type{\C}{\ebind}{\VE}}
\rule{\type{\C+\VE}{\tl{eqn rec}\;\ebind}{\VE}}
     {\type{\C}{\ebind}{\VE}}

\ruleclass{분석 방정식 정의}{Semantic Equation Binding}{\type{\C}{\ebind}{\VE}}
\rule{\type{\C}{\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind}}
	   {\{\entry{\varid}{\t}\}\;\may{+\VE}}
     }
     {\type{\C}{\e}{\t}\quad
      \may{\type{C}{\ebind}{\VE}\quad
           \varid\not\in\dom{\VE}}
     }
\rule{\type{\C}{\varid\;\tl{=}\;\e\;\may{\tl{and}\;\ebind}}
           {\{\entry{\varid}{(\t_1,\t_2,(\St_1,\St_2))}\}\;\may{+\VE}}
     }
     {\deduce{
       %\t_1'=\t_1\setminus\St_1\setminus\St_2\quad
       \may{\type{\C}{\ebind}{\VE}\quad
            \varid\not\in\dom{\VE}}
      }{
       \type{\C}{\e}{\t_1\to\t_2}\quad
       \type{\C}{\mbox{air'ed kinds}(\e)}{(\St_1,\St_2)}\quad 
       \St_1\in\t_1\quad\St_2\in\t_1
      }
     }

%\rule{\type{\E}{\nt{syntreekind}\;\nt{indexkind}}{(\St_1,\St_2)}}
%     {\SE(\setid_i)=\St_i\quad i=1,2}
%\rule{\type{\E}{\parenIt{\kind}}{(\St_1,\St_2)}}
%     {\type{\E}{\kind}{(\St_1,\St_2)}}

\ruleclass{제약식 푸는 규칙}{Constraint Closure Rules}{\notype{\C}{\ccrdec}}
\rule{\notype{\C}{\tl{ccr}\;\ccrbind}}
     {\notype{\C}{\ccrbind}}
\ruleclass{제약식 푸는 규칙 정의}{Constraint Closure Rule Binding}{\notype{\C}{\ccrbind}}
\rule{\notype{\C}{\tl{ccr}\;\cnstguard\;\tl{--}^+\;\constraintrow\;\may{\tl{|}\;\ccrbind}}}
     {\type{\C}{\cnstguard}{\VE}\quad
      \forall i.\type{\C}{\constraint_i}{\char`\_}\quad
      \may{\notype{\C}{\ccrbind}}
     }
%     {\forall i.\notype{\C}{\constraint_{1i}}\quad
%      \forall i.\notype{\C}{\constraint_{2i}}
%     }
\ruleclass{제약식 또는 조건}{Constraint or Guard Sequence}
          {\type{C}{\cnstguard}{\VE}}
\rule{\type{C}{\constraint\mbox{\ as \cnstguard}}{\VE}}
     {\type{C}{\constraint}{\VE}}
\rule{\type{C}{\guard\mbox{\ as \cnstguard}}{\{\}}}
     {\notype{C}{\guard}}
\rule{\type{C}{\cnstguard_1\;\tl{,}\;\cnstguard_2}{\VE_1+\VE_2}}
     {\type{C}{\cnstguard_1}{\VE_1}\quad
      \type{C+\VE_1}{\cnstguard_2}{\VE_2}
     }

\ruleclass{제약식 하나}{Constraint}{\type{\C}{\constraint}{\VE}}
\rule{\type{\C}{\cvarlongid\;\tl{@}\;\pat\;\tl{<-}\;\rhsexp}{\VE}}
     {\CV(\cvarlongid) = (\St,\St')\quad
      \type{\C,\St}{\rhsexp}{\VE}\quad
      \type{\C}{\pat}{\char`\_,\St'}
     }
\rule{\type{\C}{\cvarlongid\;\tl{<-}\;\rhsexp}{\VE}}
     {\CV(\cvarlongid) = \St\quad
      \type{\C,\St}{\rhsexp}{\VE}
     }

\ruleclass{제약식의 오른팔식}{Constraint's RHS Expression}
          {\type{\C,\St}{\rhsexp}{\VE}}
\rule{\type{\C,\St}{\cvarlongid}{\{\}}}
     {\CV(\cvarlongid) = \St}
\rule{\type{\C,\St}{\cvarlongid\;\tl{@}\;\pat}{\VE}}
     {\CV(\cvarlongid) = (\St,\St')\quad
      \type{\C}{\pat}{\VE,\St'}
     }
\rule{\type{\C,\St}{\conlongid}{\{\}}}
     {\CN(\conlongid) = \St}
\rule{\type{\C,\St}{\conlongid\;\cargexp}{\VE}}
     {\CN(\conlongid) = \t\to\St\quad
      \type{\C,\t}{\cargexp}{\VE}}

\ruleclass{제약식 함수심볼의 인자식}{Constraint's RHS Arguments}
          {\type{\C,\t}{\cargexp}{\VE}}
\rule{\type{\C,\t}{\cvarlongid\;\may{\tl{@}\;\pat}}{\{\}}}
     {\CV(\cvarlongid) = (\t,\St)\quad
      \may{\type{\C}{\pat}{\char`\_,\St}}
     }
\rule{\type{\C,\t}{\pat}{\VE}}
     {\type{\C}{\pat}{\VE,\t}}
\rule{\type{\C,\t}{\tl{(}\;\cargexp\;\tl{)}}{\VE}}
     {\type{\C,\t}{\cargexp}{\VE}}
\rule{\type{\C,\t_1\times\t_2}{\tl{(}\;\cargexp_1\tl{,}\;\cargexp_2\;\tl{)}}
           {\VE+\VE'}}
     {\type{\C,\t_1}{\cargexp_1}{\VE}\quad
      \type{\C,\t_2}{\cargexp_2}{\VE'}}

\ruleclass{제약식 함수심볼의 이미지}{Constraint RHS's Image}
          {\notype{\C}{\cimdec}}
\rule{\notype{\C}{\tl{cim}\;\cimbind}}
     {\notype{\C}{\cimbind}}

\ruleclass{제약식 함수심볼의 이미지 정의}{Constraint RHS's Image Binding}
          {\notype{\C}{\cimbind}}
\rule{\notype{\C}{\conlongid\;\pat\;\tl{=}\;\e\;\may{\tl{|}\;\notype{\C}{\cimbind}}}}
     {\CN(\conlongid) = \t\to\St\quad
      \type{\C}{\pat}{\VE,\t}\quad
      \type{\C+\VE}{\e}{\St}\quad
      \may{\notype{\C}{\cimbind}}}
\rule{\notype{\C}{\tl{cim}\;\conlongid\;\tl{=}\;\e\;\may{\tl{|}\;\notype{\C}{\cimbind}}}}
     {\CN(\conlongid) = \St\quad
      \type{\C+\VE}{\e}{\St}\quad
      \may{\notype{\C}{\cimbind}}}

\ruleclass{분석 결과의 탐색}{Query}{\type{C}{\querydec}{\VE}}
\rule{\label{recctlbind}\type{C}{\tl{query}\;\ctlbind}{\VE}}
     {\type{C+\VE}{\ctlbind}{\VE}}
%      \may{\type{C+\VE}{\query}{\VE'}}}
%\rule{\type{\E}{\ctlbind_1\;\ctlbind_2}{\VE_1+\VE_2}}
%     {\type{\E}{\ctlbind_1}{\VE_1}\quad
%      \type{\E}{\ctlbind_2}{\VE_2}\quad
%      \dom{\VE_1}\cap\dom{\VE_2}=\emptyset}
\note{\ref{recctlbind}}
     {\H{탐색식이 재귀적으로 정의될 수 있다.}{Recursive query-bindings
     are possible.}}

\ruleclass{탐색의 정의}{Query Formula Bind}{\type{C}{\ctlbind}{\VE}}
\rule{\type{C}{\ctlid\;\tl{=}\;\ctl\;\may{\tl{and}\;\ctlbind}}
	   {\{\entry{\ctlid}{\t}\}\;\may{+\VE'}}
     }
     {\type{C}{\ctl}{\t}\quad\may{\type{C}{\ctlbind}{\VE'}}}

\ruleclass{탐색 함수}{Query Formula}{\type{C}{\ctl}{\Lt\to\nt{bool}}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\varlongid_2}{\form/\guard}}
           {\t\to\nt{bool}}}
     {\VE(\varlongid_2)=\t\quad
      \notype{\E+\{\entry{\varid_1}{\t}\}}{\form/\guard}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\tl{pre}\;\varlongid_2}
			 {\form/\guard}}
           {\t'\to\nt{bool}}}
     {\VE(\varlongid_2)=(\t_1,\t_2,p)\quad
      \t' = \t_1\setminus p\quad
      \notype{\E+\{\entry{\varid_1}{\t'}\}}{\form/\guard}}
\rule{\type{C}{\boundCtl{\varid_1\;\tl{:}\;\tl{post}\;\varlongid_2}
		         {\form/\guard}}
           {\t_2\to\nt{bool}}}
     {\VE(\varlongid_2)=(\t_1,\t_2,p)\quad
      \notype{\E+\{\entry{\varid_1}{\t_2}\}}{\form/\guard}}
\rule{\type{C}{\parenIt{\ctl}}{\t\to\nt{bool}}}
     {\type{C}{\ctl}{\t\to\nt{bool}}}

\ruleclass{탐색 식}{Query Expression}{\notype{C}{\form}}
\rule{\notype{C}{\ctlid\;\varid}}
     {\VE(\ctlid) = \t\to\nt{bool}\quad
      \VE(\varid) = \t}
%     {\type{C}{\ctlid\;\varid}{\nt{bool}}}
\rule{\notype{C}{\tl{not}\;\form}}
     {\notype{C}{\form}}
\rule{\notype{C}{\form_1\;(\tl{and}|\tl{or}|\tl{->})\;\form_2}}
     {\notype{C}{\form_1}\quad\notype{C}{\form_2}}
\rule{\notype{C}{(\tl{A}|\tl{E})(\tl{X}|\tl{F}|\tl{G})\;\ctl}}
     {\type{C}{\ctl}{\char`\_}}
\rule{\notype{C}
       {(\tl{A}|\tl{E})\tl{U}\;\tl{(}\;\ctl_1\;\tl{,}\;\ctl_2\;\tl{)}}}
     {\type{C}{\ctl_1}{\char`\_}\quad\type{C}{\ctl_2}{\char`\_}}
\rule{\notype{C}{\parenIt{\form}}}
     {\notype{C}{\form}}

%(Kwang 10/18/02
\newpage
\section{\H{요점정리: 프로그램 분석식의 올바른 기획}
           {Digest of Well-formed Specification for Program Analysis}}
\subsection{\H{기본 분석기 일반: 집합제약식과 결과탐색식 관련 제외}{No Constraint and CTL}}
In Rabbit, user-definable sets and lattices are:
\[
\begin{array}{rcl}
\St &::= & \nt{int} \;|\;\{\elmtidrow\}\;|\;\power{\St}
    \;|\; \St_1\times\St_2\;|\;\St_1+\St_2 \;|\;\St_1\mapsto\St_2
    \;|\; \tylongidnml \\
\Lt &::= & \flat{\St}\;|\;\ordered{\St}\;|\;\power{\St}\;|\;\Lt_1\times\Lt_2
    \;|\; \Lt_1+\Lt_2\;|\;\Lt_1\mapsto\Lt_2\;|\;\St\mapsto\Lt
    \;|\; \strlongidnml \\
\end{array}
\]
For a given Rabbit program, let $S$ be the set of user-defined sets and $L$
be the set of user-defined lattices. $S$ and $L$ are finite and fixed.
When we write $\St$ or $\Lt$, we mean elements of the fixed sets $S$
or $L$ for a given Rabbit program. We call ``domains'' for $\St$ or
$\Lt$.

Every Rabbit expression has a unique mono-morphic type:
\[
\begin{array}{rcll}
\tau &::=& \nt{int}\;|\;\nt{bool} &\\
     &|& \St &\mbox{user-defined set}\\
     &|& \Lt &\mbox{user-defined lattice}\\
     &|& \tau\times\tau &\mbox{product}\\
     &|& \tau\to\tau &\mbox{function}\\
     &|& 2^\tau &\mbox{collection}\\
     &|& \tynml &\mbox{nML type}\\
\end{array}
\]
Above definition imposes the condition that expression's sum-types($+$) and
map-types($\mapsto$) are restricted to the user-defined sets and lattices.
%\bi
%\item An expression has a sum-type only if the type is in $S$ or $L$
%\item An expression has a map-type only if the type is in $S$ or $L$
%\ei

Simplified core Rabbit syntax is:
\[
\begin{array}{rcl}
a &::=& \tl{eqn $x = e,\;\cdots,\; x = e$}\\
e &::=& c \;|\; x \;|\; \lambda x.e \;|\;\delta x.e
 \;|\; e\:e\;|\;e\tl{[$e$=>$e$]} \\
  &|& e:\tau\;|\;\tl{case}\:e\:p\:e\:p\:e\;|\;\tl{($e$,$e$)}\;|\;e\tl{.}i\\
  &|& \tl{\char`\{$e$,$e$\char`\}}\;|\; e\tl{\char`\!} e
 \;|\; e\tl{+}e\;|\;e\tl{*}e\;|\;e\tl{-}e\;|\;\tl{+}e\;|\;\tl{*}e\\
  &|&  e\sqsubseteq e\;|\;\tl{if}\:e\:e\:e\;|\;\tl{/}\nexp\tl{/}\\
c &::=& \bot\;|\;\top\;|\; z\;|\;\elmtid\;|\;\tl{true}\;|\;\tl{false}\\
p &::=& c\;|\; x\;|\;\tl{\char`\_}\;|\;\tl{($p$,$p$)}
\;|\;\tl{\char`\{$p$,$p$\char`\}}
\;|\;p:\tau
\;|\;\tl{/}\npat\tl{/}
\end{array}
\]
\bi
\item $\lambda x.e$ is a function, has type $\tau_1\to\tau_2$.
\item $\delta x.e$ is a map (an element of a function
domain), has type $\St$ or $\Lt$ (user-defined domain) of either
$\St_1\to\St_2$, $\St\to\Lt$,  or $\Lt_1\to\Lt_2$.
\item $e_1\:e_2$ is overloaded for both function and map application. 
Hence $e_1$ can be a function or an element of a function domain.
\item $e\tl{[$e_1$=>$e_2$]}$ is for a change to a map, not a
computation function, i.e., $e$'s type is a function domain.
%\item $e:\tau$ is overloaded for both type annotation and type casting.
%Type annotation is for sanity check: $e$'s type is $\tau$.
%Type casting
\item \tl{($e_1$,$e_2$)} is a pair, has type $\tau_1\times\tau_2$. 
The product type is not necessarily a user-defined domain.
\item \tl{+},\tl{*},\tl{-} are overloaded: \tl{+} for set union,
lattice join, and integer addition. \tl{*} for set intersection,
lattice meet, and integer multiplication. \tl{-} for set minus and
integer subtraction.
\item \tl{\char`\{$e$,$e$\char`\}} is for a collection, has type
$2^\tau$. The collection type is not necessarily a user-defined domain.
\item \tl{+}$e$ or \tl{*}$e$ are for folding by \tl{+} and \tl{*} for
elements in $e$.
\item $e_1\tl{\char`\!} e_2$ is the collection of the results from applying
the function or map $e_1$ to every elements in collection $e_2$.
\item $e:\tau$ is for type annotation: $e$'s type is $\tau$.
\item Type casting is implicit (rules
\ref{expcast1},\ref{expcast3},\ref{patcast1},\ref{patcast3}) and
one-directional. Possible type castings are either 
 \bi
 \item from a set to its user-defined flat lattice ($\St$ to $\flat{\St}$), or
 \item from a domain to a sum domain that contains it
       ($\t$ to $(\cdots+\t+\cdots)$).
 \ei
No implicit casting is possible for the reverse direction: neither
from a sum domain into its component domain nor from a flat lattice
into its base set. Such castings must be explicitly done only by the
case expressions with type  annotations in patterns. (See examples below.)

Given Rabbit programs, optimal number of type castings are
automatically derived by Rabbit's type-checking algorithm.
Type casting happens in expressions and patterns.

For example, consider the following part of a Rabbit program:

%For another example, consider:
%
%\begin{verbatim}
%           set Z = /int/ + {--, ++}
%           lattice Int = flat Z
%        
%           fun add (++,x) = ++
%             | add (x,++) = ++
%             | add (--,x) = --
%             | add (x,--) = --
%             | add (x,y) = x+y
%\end{verbatim}
%
\begin{verbatim}
           set Age = {0...200}
           lattice L = flat Age
          
           fun add ^ = 200
             | add __ = 0
             | add x:Age = x + 1
\end{verbatim}

The {\tt add} function can have two types: \mbox{\it L$\to$int}
and \mbox{\it L$\to$L}. It can have \mbox{\it L$\to$int} with the
following type castings marked by subscripts: 
\[
\begin{array}{l}
\mbox{\tt fun add \char`\^$_{\mbox{\it L}}$ = 200}\\
\mbox{\tt \ \ | add \char`\_\char`\_$_{\mbox{\it L}}$ = 0}\\
\mbox{\tt \ \ | add (x:Age)$_{\mbox{\it L}}$  = x + 1}
\end{array}
\]
It can have \mbox{\it L$\to$L} as:
\[
\begin{array}{l}
\mbox{\tt fun add \char`\^$_{\mbox{\it L}}$ = 200$_{\mbox{\it L}}$}\\
\mbox{\tt \ \ | add \char`\_\char`\_$_{\mbox{\it L}}$ = 0$_{\mbox{\it L}}$}\\
\mbox{\tt \ \ | add (x:Age)$_{\mbox{\it L}}$  = (x + 1)$_{\mbox{\it L}}$}
\end{array}
\]
or as:
\[
\begin{array}{l}
\mbox{\tt fun add \char`\^$_{\mbox{\it L}}$ = 200$_{\mbox{\it L}}$}\\
\mbox{\tt \ \ | add \char`\_\char`\_$_{\mbox{\it L}}$ = 0$_{\mbox{\it L}}$}\\
\mbox{\tt \ \ | add (x:Age)$_{\mbox{\it L}}$  = x$_{\mbox{\it L}}$ + 1$_{\mbox{\it L}}$}
\end{array}
\]
Among the multiple typings, the contexts where the function {\tt add} is
used in the Rabbit program must determine its unique typing.

For another example, consider:

\begin{verbatim}
           set Int = /int/
           set Limit = {--,++}
           set Z = Int + Limit
        
           fun widen (x: Int) = if x >= 10 then ++ else x
             | widen (y: Limit) = y
        
           fun add (++,x) = ++
             | add (x,++) = ++
             | add (--,x) = --
             | add (x,--) = --
             | add (x,y) = x+y
\end{verbatim}

The {\tt widen} and {\tt add} respectively have type \mbox{\it Z$\to$Z}
and \mbox{\it Z$\times$Z$\:\to$Z}, with the help of type castings
marked by subscripts: 
\[
\begin{array}{l}
\mbox{\tt fun widen (x:Int)$_{\mbox{\it Z}}$
               = if x >= 10 then ++$_{\mbox{\it Z}}$ else x$_{\mbox{\it Z}}$}\\
\mbox{\tt \ \  | widen (y:Limit)$_{\mbox{\it Z}}$
               = y$_{\mbox{\it Z}}$}\\
\ \\
\mbox{\tt fun add (++$_{\mbox{\it Z}}$, x$_{\mbox{\it Z}}$)
              = ++$_{\mbox{\it Z}}$}\\
\mbox{\tt \ \ | add (x$_{\mbox{\it Z}}$, ++$_{\mbox{\it Z}}$)
              = ++$_{\mbox{\it Z}}$}\\
\mbox{\tt \ \ | add (--$_{\mbox{\it Z}}$, x$_{\mbox{\it Z}}$)
              = --$_{\mbox{\it Z}}$}\\
\mbox{\tt \ \ | add (x$_{\mbox{\it Z}}$, --$_{\mbox{\it Z}}$)
              = ++$_{\mbox{\it Z}}$}\\
\mbox{\tt \ \ | add (x$_{\mbox{\it Int}}$, y$_{\mbox{\it Int}}$)$_{\mbox{\it Z$\times$Z}}$ 
                  = (x+y)$_{\mbox{\it Z}}$}
\end{array}
\]

\ei

\subsection{\H{Rabbit 프로그램안에 있는 nML}{Embedded nML Terms}}
Inside Rabbit, nML terms can be included with delimiting slashes around them:
$\tl{/}-\tl{/}$. nML's type and structure identifiers can be used in set
and lattice declarations. nML's expressions and patterns can be used
inside Rabbit expressions. 
\bi
\item An nML's type name can be a Rabbit's set $\St$. 
An nML's structure name can be a Rabbit's lattice $\Lt$.
\item Any nML term can be included inside Rabbit programs and its nML
type is the type in Rabbit. Rabbit's type-checking system does not
check the type-safety of the embedded nML terms.
\item Because \nt{int}, \nt{bool}, and their products
and functions are common types in both nML and Rabbit, inter-operation
between nML and Rabbit must be via the common-typed values.
\ei

\chapter{\H{프로그램 분석기로의 변환}{Compiling Into Executable Analyzers}}

\H{Rabbit 프로그램(프로그램 분석식)의 의미는 분석할 프로그램들에서
분석된 결과들을 결정해 주는 함수가 된다.}
{Semantics of program analysis specification is a function from the
input programs into their analysis results. The geneerated program
analyzer will compute the function's image given the input program to
analyze.}

%\H{기획이 제대로 된 분석식은 안전한 nML 프로그램으로 항상 구현될 수 있다.}
%{Well-formed Rabbit specification gurantees to transform into typeful nML
%programs}:
%\NTheorem{Type Safety}{If $\notype{}{\spec}$ then
%$\spec\hookrightarrow\nt{topdec}_{\nt{nML}}$ and
%for an nML basis $B$, $B\vdash_{\nt{nML}}\nt{topdec}\Rightarrow B'$.}

%)Kwang
%(Kwang 10/29/02
%
%How to compile
%        eqn x1 = e1, ..., xN = eN                      (*)
%case xi's type
%          L: no parameterized equations
%   (s*L)->L: parameterized equations by programs to analyze
%             The s is the syntax trees of the programs to analyze
%
%case L: workset algorithm from (*), with initial work set {x1,...,xN}
%case (s*L)->L: given the input program, on-line algorithm.
%
%The fixpoint algorithm is basically a least fixpoint algorithm.
%The differential fixpoint algorithm. (poisson)
%Hybrid of elimination and iteration. (abyss)
%Where to put the widening/narrowing operator? Read papers.
%Start experimenting of the performance of lattice modules.
%
%

%)Kwang

\end{document}
