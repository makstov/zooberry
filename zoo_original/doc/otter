(*
 Kwangkeun Yi, The LET Project, KAIST
   
 Copyright(c) 2000 Research On Program Analysis System 
 National Creative Research Initiative Center
 Korea Advanced Institute of Science & Technology
 http://ropas.kaist.ac.kr

 All rights reserved. This file is distributed under the terms of
 an Open Source License.
*)
(*
 System Zoo
  Type-based analysis specification language Otter
*)

setdec ::= set setbind
setbind ::= setid = setexp

setexp ::=
   /tid/		// nml type id
 | setid                // zoo set id
 | [se,se]		// set of integers from n to m inclusive
 | {eid,...,eid}        // enumerated set
 | power setexp         // power set
 | setexp * setexp      // cartesian product
 | setexp + setexp      // separated sum
 | setexp -> setexp	// set of finite functions
 | cid | cid (setid,...,setid)	// regular tree grammar's right-hand-side

se ::=          // set elmt expression
    /expr/	// nml expr
  | x		// bound name
  | z           // integer
  | se + se	// integer operation
  | eid         // element id
  | {se,...,se} // powerset element
  | se U se	// set union
  | se & se	// set intersection
  | se \ se	// set minus
  | (se,...,se) // product set element
  | se . i      // projection
  | se . setid  // projection
  | se [scmp]   // product modification
  | se : setid  // sum set element: injection/projection
  | {smap,...,smap}  // finite function
  | se @ se     // function image
  | se [smap]   // function modification
  | dom se	// function domain
  | rng se	// function range
  | cid | cid (se,...,se) // constraint grammar's right-hand-side
  | (se)
ses ::= se | se , ses

scmp ::= i -> se | setid -> se  // product set component
smap ::= se -> se    // an entry
      |   _ -> se    // constant entry

vardec ::= var vars : setexp
vars ::= x | x , vars

judgment ::= ses |- /expr/ : ses
judgments ::= judgment | judgment and judgments
rules ::= rule judgments --+ judgment

(*
set Ty = Int + Arrow(Ty,Ty) + Star(Ty,Ty)

var t    : Ty
var x,y,z: /expr/ -> Val
var G    : /id/ -> Ty

rule
 G[x->t1] |- /e/ : t2
 --------------------
 G |- /LAM(x,e)/ : Arrow(t1,t2)

rule
 G |- /e1/ : Int and
 G |- /e2/ : Int
 -----------------------
 G |- /ADD(e1,e2)/ : Int

*)

(*
judgment R: (/id/->Ty) * /expr/ * t
 R(G,/ADD(e1,e2)/,Int) =  R(G,/e1/,Int), R(G,/e2/,Int)
 R(G,/LAM(x,e)/,Arrow(t1,t2)) = R(G[x->t1],/e/,t2)
*)
